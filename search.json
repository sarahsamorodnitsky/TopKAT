[{"path":"https://sarahsamorodnitsky.github.io/TopKAT/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2024 TopKAT authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://sarahsamorodnitsky.github.io/TopKAT/articles/TopKAT.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"TopKAT","text":"vignette, illustrate apply TopKAT method analyze cell-level imaging data. motivation behind TopKAT analysis multiplexed spatial proteomics imaging phenotype locations cells derived based spatial proteome. goal examine association geometry cells images patient-level outcomes. vignette rely simulated point pattern data includes contrived shapes, namely squares circles.","code":""},{"path":"https://sarahsamorodnitsky.github.io/TopKAT/articles/TopKAT.html","id":"loading-in-the-data-and-plotting","dir":"Articles","previous_headings":"","what":"Loading in the Data and Plotting","title":"TopKAT","text":"start loading packages need vignette simulated data. data organized row corresponds cell within image. PID column refers sample patient ID , case, enumerates 1 100. id column enumerates image number within sample since many applications multiple images per patient. case, PID id columns simulated single image sample. x y columns denote 2D coordinates cell locations. type column contains simulated type cell, ranging cell type 1 cell type 4. simulate data, split 100 samples two groups 50. first 50 samples, generated random numbers squares. latter 50, generated random numbers loops. two groups, also simulated different survival outcomes. outcomes simulated exponential distribution rates equal log(2)\\log(2) log(2)/2\\log(2)/2, respectively. randomly censored 10% samples. plot handful images get sense various shapes cells. apparent images exhibit contrived shapes generated cells: top row images, cells organized squares whereas second row cells organized loops. intentional order illustrate process detecting large connected components among cells (squares, first image) large loops.","code":"# Packages library(TopKAT) #> Registered S3 method overwritten by 'httr': #>   method         from   #>   print.response rmutil library(patchwork) library(survival) library(survminer) #> Loading required package: ggplot2 #> Loading required package: ggpubr #>  #> Attaching package: 'survminer' #> The following object is masked from 'package:survival': #>  #>     myeloma  # Load data data(data1.df)  # View the first few lines head(data1.df) #>   PID id        x       y        type #> 1   1  1 41.48928 16.3068 cell type 3 #> 2   1  1 42.48928 16.3068 cell type 2 #> 3   1  1 43.48928 16.3068 cell type 2 #> 4   1  1 44.48928 16.3068 cell type 4 #> 5   1  1 45.48928 16.3068 cell type 3 #> 6   1  1 46.48928 16.3068 cell type 3 # Plotting some images from the first 50 p1 <- data1.df %>% dplyr::filter(PID == 1) %>%    ggplot(aes(x = x, y = y, colour = type)) + geom_point() +   theme_bw() + ggtitle(\"Sample 1\") +   theme(legend.position = )  p2 <- data1.df %>% dplyr::filter(PID == 2) %>%    ggplot(aes(x = x, y = y, colour = type)) + geom_point() +   theme_bw() + ggtitle(\"Sample 2\")  p3 <- data1.df %>% dplyr::filter(PID == 51) %>%    ggplot(aes(x = x, y = y, colour = type)) + geom_point() +   theme_bw() + ggtitle(\"Sample 51\")  p4 <- data1.df %>% dplyr::filter(PID == 52) %>%    ggplot(aes(x = x, y = y, colour = type)) + geom_point() +   theme_bw() + ggtitle(\"Sample 52\")  # Arrange the plots (p1 + p2 + p3 + p4 & theme(legend.position = \"bottom\")) + plot_layout(guides = \"collect\")"},{"path":"https://sarahsamorodnitsky.github.io/TopKAT/articles/TopKAT.html","id":"applying-topkat","dir":"Articles","previous_headings":"","what":"Applying TopKAT","title":"TopKAT","text":"goal TopKAT test whether images similar geometric structures created cells correspond patients similar outcomes (case, survival). null alternative hypotheses test : H0H_0: association survival time topological structure cells H1H_1: association survival time topological structure cells TopKAT p-value small, evidence H0H_0. apply TopKAT, first need (1) quantify geometric arrangement cells image using persistent homology (2) calculate similarity geometric arrangements across images. geometric structures quantify connected components (degree-0 homologies) loops (degree-1 homologies). TopKAT compares images based similarities quantity size (.e., lifespan) homologies. words, two images similar number connected components loops shapes also similar sizes, similar two images differences either attributes. detect quantify size homologies, use summary statistic known persistence diagram. persistence diagram summarizes number size connected components loops. illustrate examples persistence diagrams . first step using TopKAT package calculate kernel matrices quantify similarity images. use function rips_similarity_matrix compute kernel matrices. Note compute separate kernel matrix connected components loops, meaning first compare images basis connected components basis loops, yielding two matrices quantifying pairwise similarities among images. Later, kernel association test, aggregate across matrices yield omnibus test association. , show calculate kernel matrices using rips_similarity_matrix using maximum distance 142142. chose maximum distance since images dimension 100×100100 \\times 100 142142 rounded 141.4214141.4214, diagonal images. penalty selecting distance exceeds boundaries image. quantification persistent homology stops cells connected. Note may take several minutes run, depending number cells image. rips_similarity_matrix returns two lists: (1) K.list contains two kernel matrices connected components loops (2) rips.list contains persistence diagram image. illustrate two visualizations. First, visualize corresponding persistence diagrams four samples shown .  also show visualization kernel matrices describe similarities among images. Note similarity values kernel matrices interpretable can used compare similarities two pairs images.  Finally, can test association survival given kernel matrices computed . Since two kernel matrices, may want aggregate association results across homologies. construct linear combination kernel matrices aggregate results across different mixtures. straightforward choice weights ω=(0,0.5,1)\\omega = (0, 0.5, 1) following linear combination: Kagg=(1−ω)K0+ωK1K^{agg} = (1-\\omega) K_0 + \\omega K_1 now apply TopKAT. shown , TopKAT p-value significant, 3×10−53\\times 10^{-5}. can also examine significant results linear combination kernel matrices:","code":"# Compute the similarity matrix simmat <- rips_similarity_matrix(data1.df, max.threshold = 142, print.progress = FALSE) # Plotting the persistence diagrams pd1 <- plot_persistence(simmat$rips.list[[1]], title = \"Patient 1\")  pd2 <- plot_persistence(simmat$rips.list[[2]], title = \"Patient 2\")  pd3 <- plot_persistence(simmat$rips.list[[51]], title = \"Patient 51\")  pd4 <- plot_persistence(simmat$rips.list[[52]], title = \"Patient 52\")  # Arrange the plots (pd1 + pd2 + pd3 + pd4 & theme(legend.position = \"bottom\")) + plot_layout(guides = \"collect\") # Visualize the kernel matrices for the connected components K.cc <- simmat$K.list[[1]] %>%   reshape2::melt() %>%   ggplot(aes(x = Var1, y = Var2, fill = value)) +   geom_tile(color = \"white\") +   theme_bw() +   xlab(\"Image 1\") + ylab(\"Image 2\") +   ggtitle(\"Kernel Matrix for Connected Components\") +   theme(legend.text = element_text(angle = 45, hjust = 1))     # Visualize the kernel matrices for the loops K.loop <- simmat$K.list[[2]] %>%   reshape2::melt() %>%   ggplot(aes(x = Var1, y = Var2, fill = value)) +   geom_tile(color = \"white\") +   theme_bw() +   xlab(\"Image 1\") + ylab(\"Image 2\") +   ggtitle(\"Kernel Matrix for Loops\") +   theme(legend.text = element_text(angle = 45, hjust = 1))  # Arrange the plots K.cc + K.loop & theme(legend.position = \"bottom\") # Applying TopKAT to the simulated data res <- TopKAT(y = y, X = NULL, cens = cens,               K.list = simmat$K.list, omega.list = c(0, 0.5, 1),               outcome.type = \"survival\")  # Output the p-value res$overall.pval #> [1] 3.443675e-05 res$p.vals #>      omega.0    omega.0.5      omega.1  #> 1.107707e-04 3.650099e-05 1.972696e-05"},{"path":"https://sarahsamorodnitsky.github.io/TopKAT/articles/TopKAT.html","id":"descriptive-post-hoc-analyses","dir":"Articles","previous_headings":"","what":"Descriptive Post-Hoc Analyses","title":"TopKAT","text":"far, shown significant association geometric arrangements cells images survival. can now explore distances ``important” (.e., significantly associated outcome) assess cell types connected distance. , use scale_importance function. Given sequence distances, function iteratively runs TopKAT, thresholded version persistence diagrams distance value. illustrate process, consider following image corresponding persistence diagram:  image exhibits three loops equal diameter, 3333 units. Looking birth death scales associated loops image, three loops born 3.5679283.567928 died 29.15589729.155897. sequence distances, t=0,…,Tt = 0, \\dots, T, threshold persistence diagram features born died distance tt, illustrated : threshold persistence diagram tt. apply TopKAT thresholded diagrams, calculating similarity persistence diagrams testing association outcome. resulting p-value distance stored examine connections among cells distance yields minimum p-value. set maximum distance (threshold) function select sequence distances 00 threshold run TopKAT . default select 5050 distances. first examine sequence p-values distance distance minimum TopKAT p-value arose t=28.57143t=28.57143.  can also examine simplicial complex distance looks like example images:  Finally, can examine connectivity cell types distance using connectivity matrices. matrices enumerate many connections cells t=28.5t=28.5. visualize matrices four samples given .  can also illustrative compute average connectivity matrix across whole cohort within known patient samples, shown .","code":"# Plot image and persistence diagram side-by-side p3 + pd3 # View the birth/death distances for the loops tail(simmat$rips.list[[51]]) #>       dimension    birth     death #> [87,]         0 0.000000  5.937082 #> [88,]         0 0.000000 10.961621 #> [89,]         1 6.321171  6.750254 #> [90,]         1 3.567928 29.155897 #> [91,]         1 3.567928 29.155897 #> [92,]         1 3.567928 29.155897 # Save the corresponding persistence diagram pd <- as.data.frame(simmat$rips.list[[51]])  # Threshold at t = 5 pd3.1 <- plot_persistence(pd %>% dplyr::filter(birth <= 5 & death <= 5),                            title = \"Patient 51 \\n Threshold at t=5\",                           dims = c(15, 15))  # Threshold at t=10 pd3.2 <- plot_persistence(pd %>% dplyr::filter(birth <= 10 & death <= 10),                            title = \"Patient 51 \\n Threshold at t=10\",                           dims = c(15, 15))   # Threshold at t=15 pd3.3 <- plot_persistence(pd %>% dplyr::filter(birth <= 15 & death <= 15),                            title = \"Patient 51 \\n Threshold at t=15\",                           dims = c(15, 15))   # Threshold at t=20 pd3.4 <- plot_persistence(pd %>% dplyr::filter(birth <= 20 & death <= 20),                            title = \"Patient 51 \\n Threshold at t=20\",                           dims = c(15, 15))  # Arrange (pd3.1 + pd3.2 + pd3.3 + pd3.4 & theme(legend.position = \"bottom\")) + plot_layout(guides = \"collect\") res_scale_import <- scale_importance(pd.list = simmat$rips.list,                                      y = y, cens = cens,                                       omega.list = c(0, 0.5, 1),                                      threshold = 100,                                       PIDs = 1:100,                                      outcome.type = \"survival\") # Create a data.frame res_scale_import.df <- data.frame(   thresh = res_scale_import$threshold.seq,   pval = res_scale_import$pvals )  # Plot res_scale_import.df %>%    ggplot(aes(x = thresh, y = pval)) +   geom_point() +   theme_bw() +   xlab(\"Distance\") + ylab(\"P-Value\") +   ggtitle(\"TopKAT Significance at each Distance\") +   geom_vline(xintercept = res_scale_import$min.thresh, linetype = \"dashed\") # Plot the simplicial complex at r=res_scale_import$min.thresh sc1 <- plot_cells_with_scale(   image = data1.df %>% dplyr::filter(PID == 1),   threshold = res_scale_import$min.thresh,   title = \"Simplicial Complex for \\n Sample 1\" )  sc2 <- plot_cells_with_scale(   image = data1.df %>% dplyr::filter(PID == 2),   threshold = res_scale_import$min.thresh,   title = \"Simplicial Complex for \\n Sample 2\" )  sc3 <- plot_cells_with_scale(   image = data1.df %>% dplyr::filter(PID == 51),   threshold = res_scale_import$min.thresh,   title = \"Simplicial Complex for \\n Sample 51\" )  sc4 <- plot_cells_with_scale(   image = data1.df %>% dplyr::filter(PID == 52),   threshold = res_scale_import$min.thresh,   title = \"Simplicial Complex for \\n Sample 52\" )  # Arrange the plots sc1 + sc2 + sc3 + sc4 # Connectivity matrices c1 <- plot_cell_connections(   image = data1.df %>% dplyr::filter(PID == 1),   threshold = res_scale_import$min.thresh,   title = \"Cell Connectivity for Patient 1\",   type.column = \"type\",   unique.types = unique(data1.df$type) )  c2 <- plot_cell_connections(   image = data1.df %>% dplyr::filter(PID == 2),   threshold = res_scale_import$min.thresh,   title = \"Cell Connectivity for Patient 2\",   type.column = \"type\",   unique.types = unique(data1.df$type) )  c3 <- plot_cell_connections(   image = data1.df %>% dplyr::filter(PID == 51),   threshold = res_scale_import$min.thresh,   title = \"Cell Connectivity for Patient 51\",   type.column = \"type\",   unique.types = unique(data1.df$type) )  c4 <- plot_cell_connections(   image = data1.df %>% dplyr::filter(PID == 52),   threshold = res_scale_import$min.thresh,   title = \"Cell Connectivity for Patient 52\",   type.column = \"type\",   unique.types = unique(data1.df$type) )  # Arrange the plots c1 + c2 + c3 + c4 # Save the cell types cell.types <- as.character(unique(data1.df$type))  # Connectivity matrix for mixed and segregated connect <- matrix(0, nrow = length(cell.types), ncol = length(cell.types),                      dimnames = list(cell.types, cell.types))  # Iterate through the samples for (i in 1:100) {    # Save the data   patient <- data1.df %>% dplyr::filter(PID == i)     # Plot the scale importance   connect.i <- generate_connectivity(images.df = patient,                                       threshold = res_scale_import$min.thresh,                                       type.column = \"type\",                                       unique.types = cell.types)    # Match the rows and columns in case an image was missing a cell type   match.rows <- match(rownames(connect.i), cell.types)   match.cols <- match(colnames(connect.i), cell.types)    # Add to the matrix   connect[match.rows, match.cols] <- connect[match.rows, match.cols] + connect.i  }  # Take the average connect <- connect/100  # Visualize ggplot(reshape2::melt(connect), aes(Var1, Var2, fill = value)) +     ggplot2::geom_tile(colour = \"white\") +     viridis::scale_fill_viridis(option = \"turbo\") +     ggplot2::labs(x = \"Cell Type 1\", y = \"Cell Type 2\", fill = \"Number of Connections\") +     ggplot2::theme_minimal() +     ggplot2::theme(axis.text.x = element_text(size = 12, angle = 45, hjust = 1),           axis.text.y = element_text(size = 12),           axis.title = element_text(size = 13),           panel.grid.major = element_blank(),           panel.grid.minor = element_blank(),           legend.position = \"bottom\",           legend.title = element_text(size = 12),           legend.text = element_text(size = 11, angle = 45, hjust = 0.75),           plot.title = element_text(size = 14)) +     ggplot2::ggtitle(\"Average Connectivity Matrix Across Samples\")"},{"path":"https://sarahsamorodnitsky.github.io/TopKAT/articles/example_sim_tissue.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Applying TopKAT to Simulated Tissue Data","text":"vignette, illustrate apply TopKAT method analyze cell-level imaging data. simulated data using scSpatialSIM package (Soupir et al. 2024) provide realistic example applying TopKAT imaging data cell-level resolution.","code":""},{"path":"https://sarahsamorodnitsky.github.io/TopKAT/articles/example_sim_tissue.html","id":"loading-in-the-data-and-plotting","dir":"Articles","previous_headings":"","what":"Loading in the Data and Plotting","title":"Applying TopKAT to Simulated Tissue Data","text":"start loading packages need vignette simulated data. data organized similar manner simulated dataset used Getting Started vignette. PID column refers sample patient ID , case, enumerates 1 100. id column enumerates image number within sample since many applications multiple images per patient. case, PID id columns simulated single image sample. x y columns denote 2D coordinates cell locations. type column contains simulated type cell, ranging cell type 1 cell type 4. simulate data, split 100 samples two groups 50. simulated 50 datasets scSpatialSIM package using set parameters. simulated two tissue types. split two tissue types two groups. outcomes simulated described Getting Started vignette – simulated exponential distribution rates equal log(2)\\log(2) log(2)/2\\log(2)/2, respectively. randomly censored 10% samples. plot handful images illustrate spatial patterns among cells. ## Applying TopKAT goal TopKAT test whether images similar geometric structures created cells correspond patients similar outcomes (case, survival). null alternative hypotheses test : H0H_0: association survival time topological structure cells H1H_1: association survival time topological structure cells TopKAT p-value small, evidence H0H_0. first calculate kernel matrices quantify similarity images using function rips_similarity_matrix. Note compute separate kernel matrix connected components loops. words, first compare images basis connected components basis loops, yielding two matrices quantifying pairwise similarities among images. Later, kernel association test, aggregate across matrices yield omnibus test association. , show calculate kernel matrices using rips_similarity_matrix using maximum distance 142142. illustrate two visualizations. First, visualize corresponding persistence diagrams four samples shown . latter two samples show homologies born much smaller distances, reflecting much closer cells samples 5151 100100.  also show visualization kernel matrices describe similarities among images. Note similarity values kernel matrices interpretable can used compare similarities two pairs images.  Finally, can test association survival given kernel matrices computed . Since two kernel matrices, may want aggregate association results across homologies. construct linear combination kernel matrices aggregate results across different mixtures. straightforward choice weights ω=(0,0.5,1)\\omega = (0, 0.5, 1) following linear combination: Kagg=(1−ω)K0+ωK1K^{agg} = (1-\\omega) K_0 + \\omega K_1 now apply TopKAT. shown , TopKAT p-value significant, 2×10−52\\times 10^{-5}. can also examine significant results linear combination kernel matrices:","code":"library(TopKAT) #> Registered S3 method overwritten by 'httr': #>   method         from   #>   print.response rmutil library(patchwork) library(survival) library(survminer) #> Loading required package: ggplot2 #> Loading required package: ggpubr #>  #> Attaching package: 'survminer' #> The following object is masked from 'package:survival': #>  #>     myeloma  # Load data data(data2.df)  # View the first few lines head(data2.df) #>   PID id        x         y        type #> 1   1  1 54.39235 99.700192 cell type 2 #> 2   1  1 16.21411 56.966352 cell type 3 #> 3   1  1 70.50213  2.342483 cell type 4 #> 4   1  1 93.95205 19.413240 cell type 4 #> 5   1  1 70.82572  7.031758 cell type 1 #> 6   1  1 88.23047 37.269243 cell type 3 # Plotting some images from the first 50 p1 <- data2.df %>% dplyr::filter(PID == 1) %>%    ggplot(aes(x = x, y = y, colour = type)) + geom_point() +   theme_bw() + ggtitle(\"Sample 1\") +   theme(legend.position = )  p2 <- data2.df %>% dplyr::filter(PID == 2) %>%    ggplot(aes(x = x, y = y, colour = type)) + geom_point() +   theme_bw() + ggtitle(\"Sample 2\")  p3 <- data2.df %>% dplyr::filter(PID == 51) %>%    ggplot(aes(x = x, y = y, colour = type)) + geom_point() +   theme_bw() + ggtitle(\"Sample 51\")  p4 <- data2.df %>% dplyr::filter(PID == 52) %>%    ggplot(aes(x = x, y = y, colour = type)) + geom_point() +   theme_bw() + ggtitle(\"Sample 52\")  # Arrange the plots (p1 + p2 + p3 + p4 & theme(legend.position = \"bottom\")) + plot_layout(guides = \"collect\") # Compute the similarity matrix simmat <- rips_similarity_matrix(data2.df, max.threshold = 142, print.progress = FALSE) # Plotting the persistence diagrams pd1 <- plot_persistence(simmat$rips.list[[1]], title = \"Patient 1\", dims = c(50, 50))  pd2 <- plot_persistence(simmat$rips.list[[2]], title = \"Patient 2\", dims = c(50, 50))  pd3 <- plot_persistence(simmat$rips.list[[51]], title = \"Patient 51\", dims = c(50, 50))  pd4 <- plot_persistence(simmat$rips.list[[52]], title = \"Patient 52\", dims = c(50, 50))  # Arrange the plots (pd1 + pd2 + pd3 + pd4 & theme(legend.position = \"bottom\")) + plot_layout(guides = \"collect\") # Visualize the kernel matrices for the connected components K.cc <- simmat$K.list[[1]] %>%   reshape2::melt() %>%   ggplot(aes(x = Var1, y = Var2, fill = value)) +   geom_tile(color = \"white\") +   theme_bw() +   xlab(\"Image 1\") + ylab(\"Image 2\") +   ggtitle(\"Kernel Matrix for Connected Components\") +   theme(legend.text = element_text(angle = 45, hjust = 1))     # Visualize the kernel matrices for the loops K.loop <- simmat$K.list[[2]] %>%   reshape2::melt() %>%   ggplot(aes(x = Var1, y = Var2, fill = value)) +   geom_tile(color = \"white\") +   theme_bw() +   xlab(\"Image 1\") + ylab(\"Image 2\") +   ggtitle(\"Kernel Matrix for Loops\") +   theme(legend.text = element_text(angle = 45, hjust = 1))  # Arrange the plots K.cc + K.loop & theme(legend.position = \"bottom\") # Applying TopKAT to the simulated data res <- TopKAT(y = y, X = NULL, cens = cens,               K.list = simmat$K.list, omega.list = c(0, 0.5, 1),               outcome.type = \"survival\")  # Output the p-value res$overall.pval #> [1] 2.431229e-05 res$p.vals #>      omega.0    omega.0.5      omega.1  #> 2.575420e-05 2.422430e-05 2.310274e-05"},{"path":"https://sarahsamorodnitsky.github.io/TopKAT/articles/example_sim_tissue.html","id":"descriptive-post-hoc-analyses","dir":"Articles","previous_headings":"","what":"Descriptive Post-Hoc Analyses","title":"Applying TopKAT to Simulated Tissue Data","text":"can now explore distances “important” (.e., significant) assess cell types connected distance using scale_importance function. first examine sequence p-values distance distance minimum TopKAT p-value arose t=8.163265t=8.163265.  can also examine simplicial complex distance looks like example images:  Finally, can examine connectivity cell types distance using connectivity matrices. matrices enumerate many connections cells t=8.2t = 8.2. visualize matrices four samples given .  can also illustrative compute average connectivity matrix across whole cohort within known patient samples, shown .","code":"res_scale_import <- scale_importance(pd.list = simmat$rips.list,                                      y = y, cens = cens,                                       omega.list = c(0, 0.5, 1),                                      threshold = 100,                                       PIDs = 1:100,                                      outcome.type = \"survival\") # Create a data.frame res_scale_import.df <- data.frame(   thresh = res_scale_import$threshold.seq,   pval = res_scale_import$pvals )  # Plot res_scale_import.df %>%    ggplot(aes(x = thresh, y = pval)) +   geom_point() +   theme_bw() +   xlab(\"Distance\") + ylab(\"P-Value\") +   ggtitle(\"TopKAT Significance at each Distance\") +   geom_vline(xintercept = res_scale_import$min.thresh, linetype = \"dashed\") # Plot the simplicial complex at r=res_scale_import$min.thresh sc1 <- plot_cells_with_scale(   image = data2.df %>% dplyr::filter(PID == 1),   threshold = res_scale_import$min.thresh,   title = \"Simplicial Complex for \\n Sample 1\" )  sc2 <- plot_cells_with_scale(   image = data2.df %>% dplyr::filter(PID == 2),   threshold = res_scale_import$min.thresh,   title = \"Simplicial Complex for \\n Sample 2\" )  sc3 <- plot_cells_with_scale(   image = data2.df %>% dplyr::filter(PID == 51),   threshold = res_scale_import$min.thresh,   title = \"Simplicial Complex for \\n Sample 51\" )  sc4 <- plot_cells_with_scale(   image = data2.df %>% dplyr::filter(PID == 52),   threshold = res_scale_import$min.thresh,   title = \"Simplicial Complex for \\n Sample 52\" )  # Arrange the plots sc1 + sc2 + sc3 + sc4 # Connectivity matrices c1 <- plot_cell_connections(   image = data2.df %>% dplyr::filter(PID == 1),   threshold = res_scale_import$min.thresh,   title = \"Cell Connectivity for Patient 1\",   type.column = \"type\",   unique.types = unique(data2.df$type) ) + labs(fill = \"# of Connections\")   c2 <- plot_cell_connections(   image = data2.df %>% dplyr::filter(PID == 2),   threshold = res_scale_import$min.thresh,   title = \"Cell Connectivity for Patient 2\",   type.column = \"type\",   unique.types = unique(data2.df$type) ) + labs(fill = \"# of Connections\")  c3 <- plot_cell_connections(   image = data2.df %>% dplyr::filter(PID == 51),   threshold = res_scale_import$min.thresh,   title = \"Cell Connectivity for Patient 51\",   type.column = \"type\",   unique.types = unique(data2.df$type) ) + labs(fill = \"# of Connections\")  c4 <- plot_cell_connections(   image = data2.df %>% dplyr::filter(PID == 52),   threshold = res_scale_import$min.thresh,   title = \"Cell Connectivity for Patient 52\",   type.column = \"type\",   unique.types = unique(data2.df$type) ) + labs(fill = \"# of Connections\")  # Arrange the plots c1 + c2 + c3 + c4 # Save the cell types cell.types <- as.character(unique(data2.df$type))  # Connectivity matrix for mixed and segregated connect <- matrix(0, nrow = length(cell.types), ncol = length(cell.types),                      dimnames = list(cell.types, cell.types))  # Iterate through the samples for (i in 1:100) {    # Save the data   patient <- data2.df %>% dplyr::filter(PID == i)     # Plot the scale importance   connect.i <- generate_connectivity(images.df = patient,                                       threshold = res_scale_import$min.thresh,                                       type.column = \"type\",                                       unique.types = cell.types)    # Match the rows and columns in case an image was missing a cell type   match.rows <- match(rownames(connect.i), cell.types)   match.cols <- match(colnames(connect.i), cell.types)    # Add to the matrix   connect[match.rows, match.cols] <- connect[match.rows, match.cols] + connect.i  }  # Take the average connect <- connect/100  # Visualize ggplot(reshape2::melt(connect), aes(Var1, Var2, fill = value)) +     ggplot2::geom_tile(colour = \"white\") +     viridis::scale_fill_viridis(option = \"turbo\") +     ggplot2::labs(x = \"Cell Type 1\", y = \"Cell Type 2\", fill = \"Number of Connections\") +     ggplot2::theme_minimal() +     ggplot2::theme(axis.text.x = element_text(size = 12, angle = 45, hjust = 1),           axis.text.y = element_text(size = 12),           axis.title = element_text(size = 13),           panel.grid.major = element_blank(),           panel.grid.minor = element_blank(),           legend.position = \"bottom\",           legend.title = element_text(size = 12),           legend.text = element_text(size = 11, angle = 45, hjust = 0.75),           plot.title = element_text(size = 14)) +     ggplot2::ggtitle(\"Average Connectivity Matrix Across Samples\")"},{"path":"https://sarahsamorodnitsky.github.io/TopKAT/articles/tnbc_application.html","id":"package-and-data-import","dir":"Articles","previous_headings":"","what":"Package and Data Import","title":"Application of TopKAT to a Study of Triple Negative Breast Cancer","text":"vignette demonstrates application TopKAT study triple negative breast cancer (TNBC) using MIBI-TOF probe tumor microenvironment breast cancer biopsies. data originally published Keren et al. (2018). Keren et al. observed tumor biopsies categorized based degree mixing immune cells tumor cells. biopsies, immune tumor cells colocalized interspersed together throughout tumor. biopsies referred mixed\" biopsies. others, immune cells tumor cells segregated different regions, forming connected components loops around . biopsies calledcompartmentalized.” Finally, biopsies contained immune cells altogether referred ``cold” biopsies. apparent differences spatial patterns among immune cells across biopsies motivated application TopKAT, illustrate . dataset, tnbc lazily loaded import TopKAT package. start importing packages need analysis. first save perform basics data. label cell types identified data, including non-immune cells (tumor cells, epithelial cells, mesenchymal cells, endothelial cells) several immune cell types, including Tregs, CD4 T cells, CD8 T cells, CD3 T cells, NK cells, B cells, neutrophils, macrophages, dendritic cells, DC/monocytes, monocytes/neutrophils, unidentified cell types. filtered dataset already include just immune keratin-positive tumor cells. documentation cell types published online alongside original publication. also save number biopsies dataset, n=38n=38 38 different patients. biopsy categories (mixed, compartmentalized, cold) given column tnbc$Class three levels, 0, 1, 2. coding follows: 0 = mixed 1 = compartmentalized 2 = cold , demonstrate several images dataset demonstrate different patterns among immune cells tumor cells. classification biopsies given figure titles. figures illustrate mixed samples show scatter immune tumor cells throughout tumor microenvironment, whereas compartmentalized samples show distinct clusters immune cells separate tumor cells. goals analysis two-fold. first goal relate topological structures among immune cells overall patient survival. second describe distinctions among mixed, compartmentalized, cold samples topologically. goals, focus capturing topological structures created just immune cells. address goals, going applying TopKAT just immune cells. , visualize figures just immune cells shown.","code":"# Packages library(TopKAT) library(dplyr) library(ACAT) library(ggplot2) library(tidyr) library(gtools) library(MiRKAT) library(TDAstats) library(viridis) library(patchwork)  # Load in the data data(tnbc) # Label the cell types tnbc$immuneGroup <- factor(tnbc$immuneGroup) levels(tnbc$immuneGroup) <- c(\"Non-Immune\", \"Treg\", \"CD4 T\", \"CD8 T\", \"CD3 T\", \"NK\",                               \"B cell\", \"Neutrophil\", \"Macrophage\", \"Dendritic\",                               \"DC/Mono\", \"Mono/Neu\", \"Other\")  # Rename and save the patient IDs PIDs <- as.numeric(unique(tnbc$SampleID))  # Save the number of patients n <- length(PIDs) p1_ti <- tnbc %>%   filter(SampleID == 1) %>%   mutate(Group = factor(Group)) %>%   ggplot(aes(x = x, y = y, fill = Group)) +    geom_point(color = \"black\", pch = 21) +   theme_bw() +   viridis::scale_fill_viridis(discrete = TRUE, begin = 0.35, end = 0.75,                              labels = c(\"Immune\", \"Tumor\"),                              name = \"Cell Type\") +   ggtitle(\"Example Image from Patient 1 (Mixed)\")  p2_ti <- tnbc %>%   filter(SampleID == 2) %>%   mutate(Group = factor(Group)) %>%   ggplot(aes(x = x, y = y, fill = Group)) +    geom_point(color = \"black\", pch = 21) +   theme_bw() +   viridis::scale_fill_viridis(discrete = TRUE, begin = 0.35, end = 0.75,                              labels = c(\"Immune\", \"Tumor\"),                              name = \"Cell Type\") +   ggtitle(\"Example Image from Patient 2 (Mixed)\")  p3_ti <- tnbc %>%   filter(SampleID == 3) %>%   mutate(Group = factor(Group)) %>%   ggplot(aes(x = x, y = y, fill = Group)) +    geom_point(color = \"black\", pch = 21) +   theme_bw() +   viridis::scale_fill_viridis(discrete = TRUE, begin = 0.35, end = 0.75,                              labels = c(\"Immune\", \"Tumor\"),                              name = \"Cell Type\") +   ggtitle(\"Example Image from Patient 3 (Compartmentalized)\")  p4_ti <- tnbc %>%   filter(SampleID == 4) %>%   mutate(Group = factor(Group)) %>%   ggplot(aes(x = x, y = y, fill = Group)) +    geom_point(color = \"black\", pch = 21) +   theme_bw() +   viridis::scale_fill_viridis(discrete = TRUE, begin = 0.35, end = 0.75,                              labels = c(\"Immune\", \"Tumor\"),                              name = \"Cell Type\") +   ggtitle(\"Example Image from Patient 4 (Compartmentalized)\")  # Plot p1_ti + p2_ti +   p3_ti + p4_ti +   plot_layout(ncol = 2, nrow = 2) p1_i <- tnbc %>%   filter(SampleID == 1) %>%   filter(Group == 2) %>%   mutate(Group = factor(Group)) %>%   ggplot(aes(x = x, y = y, fill = Group)) +    geom_point(color = \"black\", pch = 21) +   theme_bw() +   viridis::scale_fill_viridis(discrete = TRUE, begin = 0.35, end = 0.75,                              labels = c(\"Immune\"),                              name = \"Cell Type\") +   ggtitle(\"Example Image from Patient 1 (Mixed)\")  p2_i <- tnbc %>%   filter(SampleID == 2) %>%   filter(Group == 2) %>%   mutate(Group = factor(Group)) %>%   ggplot(aes(x = x, y = y, fill = Group)) +    geom_point(color = \"black\", pch = 21) +   theme_bw() +   viridis::scale_fill_viridis(discrete = TRUE, begin = 0.35, end = 0.75,                              labels = c(\"Immune\"),                              name = \"Cell Type\") +   ggtitle(\"Example Image from Patient 2 (Mixed)\")  p3_i <- tnbc %>%   filter(SampleID == 3) %>%   filter(Group == 2) %>%   mutate(Group = factor(Group)) %>%   ggplot(aes(x = x, y = y, fill = Group)) +    geom_point(color = \"black\", pch = 21) +   theme_bw() +   viridis::scale_fill_viridis(discrete = TRUE, begin = 0.35, end = 0.75,                              labels = c(\"Immune\"),                              name = \"Cell Type\") +   ggtitle(\"Example Image from Patient 3 (Compartmentalized)\")  p4_i <- tnbc %>%   filter(SampleID == 4) %>%   filter(Group == 2) %>%   mutate(Group = factor(Group)) %>%   ggplot(aes(x = x, y = y, fill = Group)) +    geom_point(color = \"black\", pch = 21) +   theme_bw() +   viridis::scale_fill_viridis(discrete = TRUE, begin = 0.35, end = 0.75,                              labels = c(\"Immune\"),                              name = \"Cell Type\") +   ggtitle(\"Example Image from Patient 4 (Compartmentalized)\")  p1_i + p2_i +    p3_i + p4_i +   plot_layout(ncol = 2, nrow = 2)"},{"path":"https://sarahsamorodnitsky.github.io/TopKAT/articles/tnbc_application.html","id":"applying-topkat","dir":"Articles","previous_headings":"","what":"Applying TopKAT","title":"Application of TopKAT to a Study of Triple Negative Breast Cancer","text":"first step applying TopKAT construct filtration. process filtration creates series nested graphs cell node edges drawn cells distance ϵ\\epsilon apart. goal applying filtration capture size (``lifespan”) homologies created among , case, immune cells. Homologies topological structures (connected components loops), wish capture. first subset data just immune cells (denoted ``Group == 2”). construct Rips filtration image basis just immune cells. topological structures detected throughout filtration summarized summary statistic called persistence diagram, visualized . calculated persistence diagram image, can associate persistence diagrams outcome. , use kernel machine regression framework. , need construct kernel matrix quantifies similarities among pairs persistence diagrams. obtain kernel matrix, first start calculating pairwise dissimilarity matrix. process : Calculate pairwise dissimilarity matrix persistence diagrams Convert pairwise dissimilarity matrix pairwise kernel matrix quantify similarity (rather dissimilarity) Input kernel matrix kernel machine regression framework outcome. construction dissimilarity kernel matrices occurs separately connected components loops. first start generating pairs sample IDs iterate . initialize pairwise 38×3838\\times 38 distance matrices. iterate pairs persistence diagrams calculate distance . Now distance matrices prepared, can convert kernel matrices input kernel machine regression framework. start filling lower triangular portion distance matrix (since filled upper half ). convert kernel matrix using Gower centered kernel function MiRKAT::D2K function. Since two kernel matrices, consider sequence linear combinations two test. start testing association just kernel matrix based connected components (ω=0\\omega=0 code), based 50-50 even contribution kernel matrices (ω=0.5\\omega=0.5), just kernel matrix based loops (ω=1\\omega=1). first analytical goal, test association overall survival. , demonstrate extract survival times, censoring indicator, age patient, adjust test. resulting kernel association testing p-value printed . observed significant association topological structures among immune cells overall survival. second analytical goal compare topological structures mixed, compartmentalized, cold samples. , use kernel matrices calculated pairwise comparisons mixed compartmentalized, mixed cold, compartmentalized cold samples. comparison, treat category membership binary outcome kernel test. code shows subset kernel matrix outcomes just samples within class considered comparison. print resulting p-values, show significant differences topological structure biopsy classes.","code":"# Save just the immune cells tnbc.immune <- tnbc %>% filter(Group == 2) tnbc.immune$immuneGroup <- droplevels(tnbc.immune$immuneGroup)  # Create a list to store the PDs PD.list <- lapply(1:n, function(i) list())  # Iterate through the IDs and generate a Rips complex for the immune cells for (i in PIDs) {    # Print progress   print(paste0(which(PIDs %in% i), \"/\", length(PIDs)))    # Subset the data to just this PID   data.i <- tnbc.immune %>%     filter(SampleID == i) %>%     dplyr::select(x,y)    # Construct a Rips filtration using TDAstats   rips.i <- TDAstats::calculate_homology(data.i, dim = 1, threshold = 2048)    # Save the results   PD.list[[which(PIDs %in% i)]] <- rips.i } #> [1] \"1/38\" #> [1] \"2/38\" #> [1] \"3/38\" #> [1] \"4/38\" #> [1] \"5/38\" #> [1] \"6/38\" #> [1] \"7/38\" #> [1] \"8/38\" #> [1] \"9/38\" #> [1] \"10/38\" #> [1] \"11/38\" #> [1] \"12/38\" #> [1] \"13/38\" #> [1] \"14/38\" #> [1] \"15/38\" #> [1] \"16/38\" #> [1] \"17/38\" #> [1] \"18/38\" #> [1] \"19/38\" #> [1] \"20/38\" #> [1] \"21/38\" #> [1] \"22/38\" #> [1] \"23/38\" #> [1] \"24/38\" #> [1] \"25/38\" #> [1] \"26/38\" #> [1] \"27/38\" #> [1] \"28/38\" #> [1] \"29/38\" #> [1] \"30/38\" #> [1] \"31/38\" #> [1] \"32/38\" #> [1] \"33/38\" #> [1] \"34/38\" #> [1] \"35/38\" #> [1] \"36/38\" #> [1] \"37/38\" #> [1] \"38/38\"  # Visualize a few examples pd1 <- plot_persistence(PD.list[[1]], title = \"Sample 1 (Mixed)\", dims = c(300, 300)) pd2 <- plot_persistence(PD.list[[2]], title = \"Sample 2 (Mixed)\", dims = c(300, 300)) pd3 <- plot_persistence(PD.list[[1]], title = \"Sample 3 \\n (Compartmentalized)\", dims = c(300, 300)) pd4 <- plot_persistence(PD.list[[2]], title = \"Sample 4 \\n (Compartmentalized)\", dims = c(300, 300))  pd1 + pd2 +    pd3 + pd4 +   plot_layout(ncol = 2, nrow = 2) # Create all pairs of samples pairs <- gtools::combinations(n = n, r = 2, v = sort(PIDs), repeats.allowed = FALSE)  # Initialize a distance matrix (comparing the matrices based on distance) dist.mat.deg0 <- dist.mat.deg1 <- matrix(0, nrow = n, ncol = n)  # Add names rownames(dist.mat.deg0) <- colnames(dist.mat.deg0) <-   rownames(dist.mat.deg1) <- colnames(dist.mat.deg1) <-   PIDs  # Iterate through pairs and calculate distance for (i in 1:nrow(pairs)) {    # Print progress   print(paste0(i, \"/\", nrow(pairs)))    # Save the current pair   ids <- pairs[i,]   id.1 <- ids[1]   id.2 <- ids[2]    # Load in the diagrams   rips.1 <- PD.list[[which(PIDs %in% id.1)]]   rips.2 <- PD.list[[which(PIDs %in% id.2)]]    # Calculate distance   dist.i <- phom.dist(rips.1, rips.2)    # Save the results   row.ind <- which(rownames(dist.mat.deg0) == id.1)   col.ind <- which(rownames(dist.mat.deg0) == id.2)    dist.mat.deg0[row.ind, col.ind] <- dist.i[1]   dist.mat.deg1[row.ind, col.ind] <- dist.i[2] } #> [1] \"1/703\" #> [1] \"2/703\" #> [1] \"3/703\" #> [1] \"4/703\" #> [1] \"5/703\" #> [1] \"6/703\" #> [1] \"7/703\" #> [1] \"8/703\" #> [1] \"9/703\" #> [1] \"10/703\" #> [1] \"11/703\" #> [1] \"12/703\" #> [1] \"13/703\" #> [1] \"14/703\" #> [1] \"15/703\" #> [1] \"16/703\" #> [1] \"17/703\" #> [1] \"18/703\" #> [1] \"19/703\" #> [1] \"20/703\" #> [1] \"21/703\" #> [1] \"22/703\" #> [1] \"23/703\" #> [1] \"24/703\" #> [1] \"25/703\" #> [1] \"26/703\" #> [1] \"27/703\" #> [1] \"28/703\" #> [1] \"29/703\" #> [1] \"30/703\" #> [1] \"31/703\" #> [1] \"32/703\" #> [1] \"33/703\" #> [1] \"34/703\" #> [1] \"35/703\" #> [1] \"36/703\" #> [1] \"37/703\" #> [1] \"38/703\" #> [1] \"39/703\" #> [1] \"40/703\" #> [1] \"41/703\" #> [1] \"42/703\" #> [1] \"43/703\" #> [1] \"44/703\" #> [1] \"45/703\" #> [1] \"46/703\" #> [1] \"47/703\" #> [1] \"48/703\" #> [1] \"49/703\" #> [1] \"50/703\" #> [1] \"51/703\" #> [1] \"52/703\" #> [1] \"53/703\" #> [1] \"54/703\" #> [1] \"55/703\" #> [1] \"56/703\" #> [1] \"57/703\" #> [1] \"58/703\" #> [1] \"59/703\" #> [1] \"60/703\" #> [1] \"61/703\" #> [1] \"62/703\" #> [1] \"63/703\" #> [1] \"64/703\" #> [1] \"65/703\" #> [1] \"66/703\" #> [1] \"67/703\" #> [1] \"68/703\" #> [1] \"69/703\" #> [1] \"70/703\" #> [1] \"71/703\" #> [1] \"72/703\" #> [1] \"73/703\" #> [1] \"74/703\" #> [1] \"75/703\" #> [1] \"76/703\" #> [1] \"77/703\" #> [1] \"78/703\" #> [1] \"79/703\" #> [1] \"80/703\" #> [1] \"81/703\" #> [1] \"82/703\" #> [1] \"83/703\" #> [1] \"84/703\" #> [1] \"85/703\" #> [1] \"86/703\" #> [1] \"87/703\" #> [1] \"88/703\" #> [1] \"89/703\" #> [1] \"90/703\" #> [1] \"91/703\" #> [1] \"92/703\" #> [1] \"93/703\" #> [1] \"94/703\" #> [1] \"95/703\" #> [1] \"96/703\" #> [1] \"97/703\" #> [1] \"98/703\" #> [1] \"99/703\" #> [1] \"100/703\" #> [1] \"101/703\" #> [1] \"102/703\" #> [1] \"103/703\" #> [1] \"104/703\" #> [1] \"105/703\" #> [1] \"106/703\" #> [1] \"107/703\" #> [1] \"108/703\" #> [1] \"109/703\" #> [1] \"110/703\" #> [1] \"111/703\" #> [1] \"112/703\" #> [1] \"113/703\" #> [1] \"114/703\" #> [1] \"115/703\" #> [1] \"116/703\" #> [1] \"117/703\" #> [1] \"118/703\" #> [1] \"119/703\" #> [1] \"120/703\" #> [1] \"121/703\" #> [1] \"122/703\" #> [1] \"123/703\" #> [1] \"124/703\" #> [1] \"125/703\" #> [1] \"126/703\" #> [1] \"127/703\" #> [1] \"128/703\" #> [1] \"129/703\" #> [1] \"130/703\" #> [1] \"131/703\" #> [1] \"132/703\" #> [1] \"133/703\" #> [1] \"134/703\" #> [1] \"135/703\" #> [1] \"136/703\" #> [1] \"137/703\" #> [1] \"138/703\" #> [1] \"139/703\" #> [1] \"140/703\" #> [1] \"141/703\" #> [1] \"142/703\" #> [1] \"143/703\" #> [1] \"144/703\" #> [1] \"145/703\" #> [1] \"146/703\" #> [1] \"147/703\" #> [1] \"148/703\" #> [1] \"149/703\" #> [1] \"150/703\" #> [1] \"151/703\" #> [1] \"152/703\" #> [1] \"153/703\" #> [1] \"154/703\" #> [1] \"155/703\" #> [1] \"156/703\" #> [1] \"157/703\" #> [1] \"158/703\" #> [1] \"159/703\" #> [1] \"160/703\" #> [1] \"161/703\" #> [1] \"162/703\" #> [1] \"163/703\" #> [1] \"164/703\" #> [1] \"165/703\" #> [1] \"166/703\" #> [1] \"167/703\" #> [1] \"168/703\" #> [1] \"169/703\" #> [1] \"170/703\" #> [1] \"171/703\" #> [1] \"172/703\" #> [1] \"173/703\" #> [1] \"174/703\" #> [1] \"175/703\" #> [1] \"176/703\" #> [1] \"177/703\" #> [1] \"178/703\" #> [1] \"179/703\" #> [1] \"180/703\" #> [1] \"181/703\" #> [1] \"182/703\" #> [1] \"183/703\" #> [1] \"184/703\" #> [1] \"185/703\" #> [1] \"186/703\" #> [1] \"187/703\" #> [1] \"188/703\" #> [1] \"189/703\" #> [1] \"190/703\" #> [1] \"191/703\" #> [1] \"192/703\" #> [1] \"193/703\" #> [1] \"194/703\" #> [1] \"195/703\" #> [1] \"196/703\" #> [1] \"197/703\" #> [1] \"198/703\" #> [1] \"199/703\" #> [1] \"200/703\" #> [1] \"201/703\" #> [1] \"202/703\" #> [1] \"203/703\" #> [1] \"204/703\" #> [1] \"205/703\" #> [1] \"206/703\" #> [1] \"207/703\" #> [1] \"208/703\" #> [1] \"209/703\" #> [1] \"210/703\" #> [1] \"211/703\" #> [1] \"212/703\" #> [1] \"213/703\" #> [1] \"214/703\" #> [1] \"215/703\" #> [1] \"216/703\" #> [1] \"217/703\" #> [1] \"218/703\" #> [1] \"219/703\" #> [1] \"220/703\" #> [1] \"221/703\" #> [1] \"222/703\" #> [1] \"223/703\" #> [1] \"224/703\" #> [1] \"225/703\" #> [1] \"226/703\" #> [1] \"227/703\" #> [1] \"228/703\" #> [1] \"229/703\" #> [1] \"230/703\" #> [1] \"231/703\" #> [1] \"232/703\" #> [1] \"233/703\" #> [1] \"234/703\" #> [1] \"235/703\" #> [1] \"236/703\" #> [1] \"237/703\" #> [1] \"238/703\" #> [1] \"239/703\" #> [1] \"240/703\" #> [1] \"241/703\" #> [1] \"242/703\" #> [1] \"243/703\" #> [1] \"244/703\" #> [1] \"245/703\" #> [1] \"246/703\" #> [1] \"247/703\" #> [1] \"248/703\" #> [1] \"249/703\" #> [1] \"250/703\" #> [1] \"251/703\" #> [1] \"252/703\" #> [1] \"253/703\" #> [1] \"254/703\" #> [1] \"255/703\" #> [1] \"256/703\" #> [1] \"257/703\" #> [1] \"258/703\" #> [1] \"259/703\" #> [1] \"260/703\" #> [1] \"261/703\" #> [1] \"262/703\" #> [1] \"263/703\" #> [1] \"264/703\" #> [1] \"265/703\" #> [1] \"266/703\" #> [1] \"267/703\" #> [1] \"268/703\" #> [1] \"269/703\" #> [1] \"270/703\" #> [1] \"271/703\" #> [1] \"272/703\" #> [1] \"273/703\" #> [1] \"274/703\" #> [1] \"275/703\" #> [1] \"276/703\" #> [1] \"277/703\" #> [1] \"278/703\" #> [1] \"279/703\" #> [1] \"280/703\" #> [1] \"281/703\" #> [1] \"282/703\" #> [1] \"283/703\" #> [1] \"284/703\" #> [1] \"285/703\" #> [1] \"286/703\" #> [1] \"287/703\" #> [1] \"288/703\" #> [1] \"289/703\" #> [1] \"290/703\" #> [1] \"291/703\" #> [1] \"292/703\" #> [1] \"293/703\" #> [1] \"294/703\" #> [1] \"295/703\" #> [1] \"296/703\" #> [1] \"297/703\" #> [1] \"298/703\" #> [1] \"299/703\" #> [1] \"300/703\" #> [1] \"301/703\" #> [1] \"302/703\" #> [1] \"303/703\" #> [1] \"304/703\" #> [1] \"305/703\" #> [1] \"306/703\" #> [1] \"307/703\" #> [1] \"308/703\" #> [1] \"309/703\" #> [1] \"310/703\" #> [1] \"311/703\" #> [1] \"312/703\" #> [1] \"313/703\" #> [1] \"314/703\" #> [1] \"315/703\" #> [1] \"316/703\" #> [1] \"317/703\" #> [1] \"318/703\" #> [1] \"319/703\" #> [1] \"320/703\" #> [1] \"321/703\" #> [1] \"322/703\" #> [1] \"323/703\" #> [1] \"324/703\" #> [1] \"325/703\" #> [1] \"326/703\" #> [1] \"327/703\" #> [1] \"328/703\" #> [1] \"329/703\" #> [1] \"330/703\" #> [1] \"331/703\" #> [1] \"332/703\" #> [1] \"333/703\" #> [1] \"334/703\" #> [1] \"335/703\" #> [1] \"336/703\" #> [1] \"337/703\" #> [1] \"338/703\" #> [1] \"339/703\" #> [1] \"340/703\" #> [1] \"341/703\" #> [1] \"342/703\" #> [1] \"343/703\" #> [1] \"344/703\" #> [1] \"345/703\" #> [1] \"346/703\" #> [1] \"347/703\" #> [1] \"348/703\" #> [1] \"349/703\" #> [1] \"350/703\" #> [1] \"351/703\" #> [1] \"352/703\" #> [1] \"353/703\" #> [1] \"354/703\" #> [1] \"355/703\" #> [1] \"356/703\" #> [1] \"357/703\" #> [1] \"358/703\" #> [1] \"359/703\" #> [1] \"360/703\" #> [1] \"361/703\" #> [1] \"362/703\" #> [1] \"363/703\" #> [1] \"364/703\" #> [1] \"365/703\" #> [1] \"366/703\" #> [1] \"367/703\" #> [1] \"368/703\" #> [1] \"369/703\" #> [1] \"370/703\" #> [1] \"371/703\" #> [1] \"372/703\" #> [1] \"373/703\" #> [1] \"374/703\" #> [1] \"375/703\" #> [1] \"376/703\" #> [1] \"377/703\" #> [1] \"378/703\" #> [1] \"379/703\" #> [1] \"380/703\" #> [1] \"381/703\" #> [1] \"382/703\" #> [1] \"383/703\" #> [1] \"384/703\" #> [1] \"385/703\" #> [1] \"386/703\" #> [1] \"387/703\" #> [1] \"388/703\" #> [1] \"389/703\" #> [1] \"390/703\" #> [1] \"391/703\" #> [1] \"392/703\" #> [1] \"393/703\" #> [1] \"394/703\" #> [1] \"395/703\" #> [1] \"396/703\" #> [1] \"397/703\" #> [1] \"398/703\" #> [1] \"399/703\" #> [1] \"400/703\" #> [1] \"401/703\" #> [1] \"402/703\" #> [1] \"403/703\" #> [1] \"404/703\" #> [1] \"405/703\" #> [1] \"406/703\" #> [1] \"407/703\" #> [1] \"408/703\" #> [1] \"409/703\" #> [1] \"410/703\" #> [1] \"411/703\" #> [1] \"412/703\" #> [1] \"413/703\" #> [1] \"414/703\" #> [1] \"415/703\" #> [1] \"416/703\" #> [1] \"417/703\" #> [1] \"418/703\" #> [1] \"419/703\" #> [1] \"420/703\" #> [1] \"421/703\" #> [1] \"422/703\" #> [1] \"423/703\" #> [1] \"424/703\" #> [1] \"425/703\" #> [1] \"426/703\" #> [1] \"427/703\" #> [1] \"428/703\" #> [1] \"429/703\" #> [1] \"430/703\" #> [1] \"431/703\" #> [1] \"432/703\" #> [1] \"433/703\" #> [1] \"434/703\" #> [1] \"435/703\" #> [1] \"436/703\" #> [1] \"437/703\" #> [1] \"438/703\" #> [1] \"439/703\" #> [1] \"440/703\" #> [1] \"441/703\" #> [1] \"442/703\" #> [1] \"443/703\" #> [1] \"444/703\" #> [1] \"445/703\" #> [1] \"446/703\" #> [1] \"447/703\" #> [1] \"448/703\" #> [1] \"449/703\" #> [1] \"450/703\" #> [1] \"451/703\" #> [1] \"452/703\" #> [1] \"453/703\" #> [1] \"454/703\" #> [1] \"455/703\" #> [1] \"456/703\" #> [1] \"457/703\" #> [1] \"458/703\" #> [1] \"459/703\" #> [1] \"460/703\" #> [1] \"461/703\" #> [1] \"462/703\" #> [1] \"463/703\" #> [1] \"464/703\" #> [1] \"465/703\" #> [1] \"466/703\" #> [1] \"467/703\" #> [1] \"468/703\" #> [1] \"469/703\" #> [1] \"470/703\" #> [1] \"471/703\" #> [1] \"472/703\" #> [1] \"473/703\" #> [1] \"474/703\" #> [1] \"475/703\" #> [1] \"476/703\" #> [1] \"477/703\" #> [1] \"478/703\" #> [1] \"479/703\" #> [1] \"480/703\" #> [1] \"481/703\" #> [1] \"482/703\" #> [1] \"483/703\" #> [1] \"484/703\" #> [1] \"485/703\" #> [1] \"486/703\" #> [1] \"487/703\" #> [1] \"488/703\" #> [1] \"489/703\" #> [1] \"490/703\" #> [1] \"491/703\" #> [1] \"492/703\" #> [1] \"493/703\" #> [1] \"494/703\" #> [1] \"495/703\" #> [1] \"496/703\" #> [1] \"497/703\" #> [1] \"498/703\" #> [1] \"499/703\" #> [1] \"500/703\" #> [1] \"501/703\" #> [1] \"502/703\" #> [1] \"503/703\" #> [1] \"504/703\" #> [1] \"505/703\" #> [1] \"506/703\" #> [1] \"507/703\" #> [1] \"508/703\" #> [1] \"509/703\" #> [1] \"510/703\" #> [1] \"511/703\" #> [1] \"512/703\" #> [1] \"513/703\" #> [1] \"514/703\" #> [1] \"515/703\" #> [1] \"516/703\" #> [1] \"517/703\" #> [1] \"518/703\" #> [1] \"519/703\" #> [1] \"520/703\" #> [1] \"521/703\" #> [1] \"522/703\" #> [1] \"523/703\" #> [1] \"524/703\" #> [1] \"525/703\" #> [1] \"526/703\" #> [1] \"527/703\" #> [1] \"528/703\" #> [1] \"529/703\" #> [1] \"530/703\" #> [1] \"531/703\" #> [1] \"532/703\" #> [1] \"533/703\" #> [1] \"534/703\" #> [1] \"535/703\" #> [1] \"536/703\" #> [1] \"537/703\" #> [1] \"538/703\" #> [1] \"539/703\" #> [1] \"540/703\" #> [1] \"541/703\" #> [1] \"542/703\" #> [1] \"543/703\" #> [1] \"544/703\" #> [1] \"545/703\" #> [1] \"546/703\" #> [1] \"547/703\" #> [1] \"548/703\" #> [1] \"549/703\" #> [1] \"550/703\" #> [1] \"551/703\" #> [1] \"552/703\" #> [1] \"553/703\" #> [1] \"554/703\" #> [1] \"555/703\" #> [1] \"556/703\" #> [1] \"557/703\" #> [1] \"558/703\" #> [1] \"559/703\" #> [1] \"560/703\" #> [1] \"561/703\" #> [1] \"562/703\" #> [1] \"563/703\" #> [1] \"564/703\" #> [1] \"565/703\" #> [1] \"566/703\" #> [1] \"567/703\" #> [1] \"568/703\" #> [1] \"569/703\" #> [1] \"570/703\" #> [1] \"571/703\" #> [1] \"572/703\" #> [1] \"573/703\" #> [1] \"574/703\" #> [1] \"575/703\" #> [1] \"576/703\" #> [1] \"577/703\" #> [1] \"578/703\" #> [1] \"579/703\" #> [1] \"580/703\" #> [1] \"581/703\" #> [1] \"582/703\" #> [1] \"583/703\" #> [1] \"584/703\" #> [1] \"585/703\" #> [1] \"586/703\" #> [1] \"587/703\" #> [1] \"588/703\" #> [1] \"589/703\" #> [1] \"590/703\" #> [1] \"591/703\" #> [1] \"592/703\" #> [1] \"593/703\" #> [1] \"594/703\" #> [1] \"595/703\" #> [1] \"596/703\" #> [1] \"597/703\" #> [1] \"598/703\" #> [1] \"599/703\" #> [1] \"600/703\" #> [1] \"601/703\" #> [1] \"602/703\" #> [1] \"603/703\" #> [1] \"604/703\" #> [1] \"605/703\" #> [1] \"606/703\" #> [1] \"607/703\" #> [1] \"608/703\" #> [1] \"609/703\" #> [1] \"610/703\" #> [1] \"611/703\" #> [1] \"612/703\" #> [1] \"613/703\" #> [1] \"614/703\" #> [1] \"615/703\" #> [1] \"616/703\" #> [1] \"617/703\" #> [1] \"618/703\" #> [1] \"619/703\" #> [1] \"620/703\" #> [1] \"621/703\" #> [1] \"622/703\" #> [1] \"623/703\" #> [1] \"624/703\" #> [1] \"625/703\" #> [1] \"626/703\" #> [1] \"627/703\" #> [1] \"628/703\" #> [1] \"629/703\" #> [1] \"630/703\" #> [1] \"631/703\" #> [1] \"632/703\" #> [1] \"633/703\" #> [1] \"634/703\" #> [1] \"635/703\" #> [1] \"636/703\" #> [1] \"637/703\" #> [1] \"638/703\" #> [1] \"639/703\" #> [1] \"640/703\" #> [1] \"641/703\" #> [1] \"642/703\" #> [1] \"643/703\" #> [1] \"644/703\" #> [1] \"645/703\" #> [1] \"646/703\" #> [1] \"647/703\" #> [1] \"648/703\" #> [1] \"649/703\" #> [1] \"650/703\" #> [1] \"651/703\" #> [1] \"652/703\" #> [1] \"653/703\" #> [1] \"654/703\" #> [1] \"655/703\" #> [1] \"656/703\" #> [1] \"657/703\" #> [1] \"658/703\" #> [1] \"659/703\" #> [1] \"660/703\" #> [1] \"661/703\" #> [1] \"662/703\" #> [1] \"663/703\" #> [1] \"664/703\" #> [1] \"665/703\" #> [1] \"666/703\" #> [1] \"667/703\" #> [1] \"668/703\" #> [1] \"669/703\" #> [1] \"670/703\" #> [1] \"671/703\" #> [1] \"672/703\" #> [1] \"673/703\" #> [1] \"674/703\" #> [1] \"675/703\" #> [1] \"676/703\" #> [1] \"677/703\" #> [1] \"678/703\" #> [1] \"679/703\" #> [1] \"680/703\" #> [1] \"681/703\" #> [1] \"682/703\" #> [1] \"683/703\" #> [1] \"684/703\" #> [1] \"685/703\" #> [1] \"686/703\" #> [1] \"687/703\" #> [1] \"688/703\" #> [1] \"689/703\" #> [1] \"690/703\" #> [1] \"691/703\" #> [1] \"692/703\" #> [1] \"693/703\" #> [1] \"694/703\" #> [1] \"695/703\" #> [1] \"696/703\" #> [1] \"697/703\" #> [1] \"698/703\" #> [1] \"699/703\" #> [1] \"700/703\" #> [1] \"701/703\" #> [1] \"702/703\" #> [1] \"703/703\" # Convert the distance matrices to symmetric matrices dist.mat.deg0 <- dist.mat.deg0 + t(dist.mat.deg0) dist.mat.deg1 <- dist.mat.deg1 + t(dist.mat.deg1)  # Construct kernel (similarity) matrix K.list <- list(dim0 = D2K(dist.mat.deg0), dim1 = D2K(dist.mat.deg1))  # Set a list of weights omega.list <- c(0, 0.5, 1)  # Save just the immune cells tnbc.immune <- tnbc %>% filter(Group == 2)  # Subset the clinical data tnbc.immune.clin.only <- tnbc.immune %>%   dplyr::select(all_of(c(\"SampleID\", \"Survival_days_capped*\", \"Censored\", \"AGE_AT_DX\", \"Class\"))) %>%   dplyr::distinct()  # Convert the survival times, censor indicator, and age vectors to numeric tnbc.immune.clin.only$`Survival_days_capped*` <- as.numeric(tnbc.immune.clin.only$`Survival_days_capped*`) tnbc.immune.clin.only$Censored <- as.numeric(tnbc.immune.clin.only$Censored) tnbc.immune.clin.only$AGE_AT_DX <- as.numeric(tnbc.immune.clin.only$AGE_AT_DX)  # Predict survival using Davies method survival.pred <- TopKAT(y = tnbc.immune.clin.only$`Survival_days_capped*`,                           X = matrix(tnbc.immune.clin.only$AGE_AT_DX),                           cens = tnbc.immune.clin.only$Censored,                           K.list = K.list,                           omega.list = omega.list,                           outcome.type = \"survival\") #> Warning in MiRKAT::MiRKATS(obstime = y, delta = cens, X = X, Ks = K.aggregate, : Permutation p-values are recommendeded when n #> <= 50.  survival.pred$overall.pval #> [1] 0.0118498 # First, do pairwise comparisons of each group --  # 0/1 dist.mat.deg0.0vs1 <- dist.mat.deg0[   rownames(dist.mat.deg0) %in% tnbc.immune.clin.only$SampleID[tnbc.immune.clin.only$Class %in% c(0,1)],   colnames(dist.mat.deg0) %in% tnbc.immune.clin.only$SampleID[tnbc.immune.clin.only$Class %in% c(0,1)]   ]  dist.mat.deg1.0vs1 <- dist.mat.deg1[   rownames(dist.mat.deg1) %in% tnbc.immune.clin.only$SampleID[tnbc.immune.clin.only$Class %in% c(0,1)],   colnames(dist.mat.deg1) %in% tnbc.immune.clin.only$SampleID[tnbc.immune.clin.only$Class %in% c(0,1)]   ]  # Check ordering all(rownames(dist.mat.deg0.0vs1) == tnbc.immune.clin.only$SampleID[tnbc.immune.clin.only$Class %in% c(0,1)]) # TRUE! #> [1] TRUE all(rownames(dist.mat.deg1.0vs1) == tnbc.immune.clin.only$SampleID[tnbc.immune.clin.only$Class %in% c(0,1)]) # TRUE! #> [1] TRUE  all(colnames(dist.mat.deg0.0vs1) == tnbc.immune.clin.only$SampleID[tnbc.immune.clin.only$Class %in% c(0,1)]) # TRUE! #> [1] TRUE all(colnames(dist.mat.deg1.0vs1) == tnbc.immune.clin.only$SampleID[tnbc.immune.clin.only$Class %in% c(0,1)]) # TRUE! #> [1] TRUE  # Construct kernel (similarity) matrix K.list.01 <- list(dim0 = D2K(dist.mat.deg0.0vs1), dim1 = D2K(dist.mat.deg1.0vs1))  # Set the outcome class01 <- tnbc.immune.clin.only$Class class01 <- class01[class01 %in% c(0,1)]  # Predict class class01.pred <- TopKAT(y = class01,                          K.list = K.list.01,                          omega.list = omega.list,                          outcome.type = \"binary\") #> Warning in MiRKAT_binary(y, X = X, Ks = Ks, method = method, omnibus = omnibus, : For binary outcome and n < 50, p-value using #> davies method can be inaccurate at tails, permutation is recommended.  class01.pred$overall.pval #> [1] 0.0004638182  # 0/2 dist.mat.deg0.0vs2 <- dist.mat.deg0[   rownames(dist.mat.deg0) %in% tnbc.immune.clin.only$SampleID[tnbc.immune.clin.only$Class %in% c(0,2)],   colnames(dist.mat.deg0) %in% tnbc.immune.clin.only$SampleID[tnbc.immune.clin.only$Class %in% c(0,2)]   ]  dist.mat.deg1.0vs2 <- dist.mat.deg1[   rownames(dist.mat.deg1) %in% tnbc.immune.clin.only$SampleID[tnbc.immune.clin.only$Class %in% c(0,2)],   colnames(dist.mat.deg1) %in% tnbc.immune.clin.only$SampleID[tnbc.immune.clin.only$Class %in% c(0,2)]   ]  # Check ordering all(rownames(dist.mat.deg0.0vs2) == tnbc.immune.clin.only$SampleID[tnbc.immune.clin.only$Class %in% c(0,2)]) # TRUE! #> [1] TRUE all(rownames(dist.mat.deg1.0vs2) == tnbc.immune.clin.only$SampleID[tnbc.immune.clin.only$Class %in% c(0,2)]) # TRUE! #> [1] TRUE  all(colnames(dist.mat.deg0.0vs2) == tnbc.immune.clin.only$SampleID[tnbc.immune.clin.only$Class %in% c(0,2)]) # TRUE! #> [1] TRUE all(colnames(dist.mat.deg1.0vs2) == tnbc.immune.clin.only$SampleID[tnbc.immune.clin.only$Class %in% c(0,2)]) # TRUE! #> [1] TRUE  # Construct kernel (similarity) matrix K.list.02 <- list(dim0 = D2K(dist.mat.deg0.0vs2), dim1 = D2K(dist.mat.deg1.0vs2))  # Set the outcome class02 <- tnbc.immune.clin.only$Class class02 <- class02[class02 %in% c(0,2)] class02[class02 == 2] <- 1  # Predict class class02.pred <- TopKAT(y = class02,                          K.list = K.list.02,                          omega.list = omega.list,                          outcome.type = \"binary\") #> Warning in MiRKAT_binary(y, X = X, Ks = Ks, method = method, omnibus = omnibus, : For binary outcome and n < 50, p-value using #> davies method can be inaccurate at tails, permutation is recommended.  class02.pred$overall.pval #> [1] 0.01118632  # 1/2 dist.mat.deg0.1vs2 <- dist.mat.deg0[   rownames(dist.mat.deg0) %in% tnbc.immune.clin.only$SampleID[tnbc.immune.clin.only$Class %in% c(1,2)],   colnames(dist.mat.deg0) %in% tnbc.immune.clin.only$SampleID[tnbc.immune.clin.only$Class %in% c(1,2)]   ]  dist.mat.deg1.1vs2 <- dist.mat.deg1[   rownames(dist.mat.deg1) %in% tnbc.immune.clin.only$SampleID[tnbc.immune.clin.only$Class %in% c(1,2)],   colnames(dist.mat.deg1) %in% tnbc.immune.clin.only$SampleID[tnbc.immune.clin.only$Class %in% c(1,2)]   ]  # Check ordering all(rownames(dist.mat.deg0.1vs2) == tnbc.immune.clin.only$SampleID[tnbc.immune.clin.only$Class %in% c(1,2)]) # TRUE! #> [1] TRUE all(rownames(dist.mat.deg1.1vs2) == tnbc.immune.clin.only$SampleID[tnbc.immune.clin.only$Class %in% c(1,2)]) # TRUE! #> [1] TRUE  all(colnames(dist.mat.deg0.1vs2) == tnbc.immune.clin.only$SampleID[tnbc.immune.clin.only$Class %in% c(1,2)]) # TRUE! #> [1] TRUE all(colnames(dist.mat.deg1.1vs2) == tnbc.immune.clin.only$SampleID[tnbc.immune.clin.only$Class %in% c(1,2)]) # TRUE! #> [1] TRUE  # Construct kernel (similarity) matrix K.list.12 <- list(dim0 = D2K(dist.mat.deg0.1vs2), dim1 = D2K(dist.mat.deg1.1vs2))  # Set the outcome class12 <- tnbc.immune.clin.only$Class class12 <- class12[class12 %in% c(1,2)] class12[class12 == 1] <- 0 class12[class12 == 2] <- 1  # Predict class class12.pred <- TopKAT(y = class12,                          K.list = K.list.12,                          omega.list = omega.list,                          outcome.type = \"binary\") #> Warning in MiRKAT_binary(y, X = X, Ks = Ks, method = method, omnibus = omnibus, : For binary outcome and n < 50, p-value using #> davies method can be inaccurate at tails, permutation is recommended.  class12.pred$overall.pval #> [1] 5.080601e-05"},{"path":[]},{"path":"https://sarahsamorodnitsky.github.io/TopKAT/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Sarah Samorodnitsky. Author, maintainer.","code":""},{"path":"https://sarahsamorodnitsky.github.io/TopKAT/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Samorodnitsky S (2025). TopKAT: Topological Kernel Association Test (TopKAT). R package version 0.0.0.9000, https://sarahsamorodnitsky.github.io/TopKAT/.","code":"@Manual{,   title = {TopKAT: Topological Kernel Association Test (TopKAT)},   author = {Sarah Samorodnitsky},   year = {2025},   note = {R package version 0.0.0.9000},   url = {https://sarahsamorodnitsky.github.io/TopKAT/}, }"},{"path":"https://sarahsamorodnitsky.github.io/TopKAT/index.html","id":"topkat-topological-kernel-association-test-","dir":"","previous_headings":"","what":"Topological Kernel Association Test (TopKAT)","title":"Topological Kernel Association Test (TopKAT)","text":"TopKAT global test association topological (geometric) structure cells cell-level imaging data patient-level outcomes. goal TopKAT package provide software run test post-hoc analyses results.","code":""},{"path":"https://sarahsamorodnitsky.github.io/TopKAT/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Topological Kernel Association Test (TopKAT)","text":"can install development version TopKAT Github via: TopKAT relies several dependencies: MiRKAT, RcppAlgos, TDAstats, dplyr, ggplot2, ggtda, reshape2, tidyr, viridis, igraph, magrittr. underlying engine running persistent homology TDAstats. ggtda, facilitates visualization filtration process persistence diagrams available Github.","code":"# First, install devtools if (!require(\"devtools\", quietly = TRUE)) {   install.packages(\"devtools\") }  # Install from Github devtools::install_github(\"sarahsamorodnitsky/TopKAT\")"},{"path":"https://sarahsamorodnitsky.github.io/TopKAT/index.html","id":"vignettes","dir":"","previous_headings":"","what":"Vignettes","title":"Topological Kernel Association Test (TopKAT)","text":"Example usage TopKAT analyze data provided two vignetes: Getting Started: illustrates application TopKAT simulated dataset containing contrived shapes. Simulated Tissue: illustrates application TopKAT dataset simulated using scSpatialSIM package. [1]","code":""},{"path":"https://sarahsamorodnitsky.github.io/TopKAT/index.html","id":"references","dir":"","previous_headings":"","what":"References","title":"Topological Kernel Association Test (TopKAT)","text":"[1] Soupir, . C., et al. (2024). scSpatialSIM: simulator spatial single-cell molecular data. bioRxiv, 2024-02.","code":""},{"path":"https://sarahsamorodnitsky.github.io/TopKAT/reference/TopKAT.html","id":null,"dir":"Reference","previous_headings":"","what":"Topological Kernel Association Test (TopKAT) — TopKAT","title":"Topological Kernel Association Test (TopKAT) — TopKAT","text":"Perform global test association geometric (topological) structures spatially-resolved images cells continuous, binary, survival outcomes.","code":""},{"path":"https://sarahsamorodnitsky.github.io/TopKAT/reference/TopKAT.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Topological Kernel Association Test (TopKAT) — TopKAT","text":"","code":"TopKAT(   y,   X = NULL,   cens = NULL,   K.list,   omega.list,   outcome.type = \"continuous\" )"},{"path":"https://sarahsamorodnitsky.github.io/TopKAT/reference/TopKAT.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Topological Kernel Association Test (TopKAT) — TopKAT","text":"y Vector outcomes. Must numeric. continuous survival data, numeric vector. binary outcome, must consist 0s 1s. X Matrix covariates adjust . May left NULL. cens Vector event indicators survival outcome. 1 indicates sample experienced event, 0 otherwise. using survival outcome, leave NULL. K.list List 2 kernel matrices corresponding similarities among connected components among loops. May provide 1 kernel matrix interested specific homology. omega.list Vector weights create different combinations kernel matrices. suggested options: c(0, 1) TopKAT combine p-values test associating connected components y loops y separately; c(0, 0.5, 1) combine p-values across just connected components, even split connected components loops, just loops. outcome.type kind outcome y? Options include \"continuous\", \"binary\", \"survival\"","code":""},{"path":"https://sarahsamorodnitsky.github.io/TopKAT/reference/TopKAT.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Topological Kernel Association Test (TopKAT) — TopKAT","text":"Returns list following objects: overall.pval: overall p-value describing association similarities topological structures clinical outcomes, p.vals: vector individual p-values weight omega.list, y: outcome provided, X: covariates provided, omega.list: vector weights provided, outcome.type: outcome type specified","code":""},{"path":"https://sarahsamorodnitsky.github.io/TopKAT/reference/TopKAT.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Topological Kernel Association Test (TopKAT) — TopKAT","text":"","code":"# First, construct the similarity matrix simmat <- rips_similarity_matrix(data1.df, max.threshold = 100, print.progress = TRUE) #> [1] \"Rips diagram: 1\" #> [1] \"Rips diagram: 2\" #> [1] \"Rips diagram: 3\" #> [1] \"Rips diagram: 4\" #> [1] \"Rips diagram: 5\" #> [1] \"Rips diagram: 6\" #> [1] \"Rips diagram: 7\" #> [1] \"Rips diagram: 8\" #> [1] \"Rips diagram: 9\" #> [1] \"Rips diagram: 10\" #> [1] \"Rips diagram: 11\" #> [1] \"Rips diagram: 12\" #> [1] \"Rips diagram: 13\" #> [1] \"Rips diagram: 14\" #> [1] \"Rips diagram: 15\" #> [1] \"Rips diagram: 16\" #> [1] \"Rips diagram: 17\" #> [1] \"Rips diagram: 18\" #> [1] \"Rips diagram: 19\" #> [1] \"Rips diagram: 20\" #> [1] \"Rips diagram: 21\" #> [1] \"Rips diagram: 22\" #> [1] \"Rips diagram: 23\" #> [1] \"Rips diagram: 24\" #> [1] \"Rips diagram: 25\" #> [1] \"Rips diagram: 26\" #> [1] \"Rips diagram: 27\" #> [1] \"Rips diagram: 28\" #> [1] \"Rips diagram: 29\" #> [1] \"Rips diagram: 30\" #> [1] \"Rips diagram: 31\" #> [1] \"Rips diagram: 32\" #> [1] \"Rips diagram: 33\" #> [1] \"Rips diagram: 34\" #> [1] \"Rips diagram: 35\" #> [1] \"Rips diagram: 36\" #> [1] \"Rips diagram: 37\" #> [1] \"Rips diagram: 38\" #> [1] \"Rips diagram: 39\" #> [1] \"Rips diagram: 40\" #> [1] \"Rips diagram: 41\" #> [1] \"Rips diagram: 42\" #> [1] \"Rips diagram: 43\" #> [1] \"Rips diagram: 44\" #> [1] \"Rips diagram: 45\" #> [1] \"Rips diagram: 46\" #> [1] \"Rips diagram: 47\" #> [1] \"Rips diagram: 48\" #> [1] \"Rips diagram: 49\" #> [1] \"Rips diagram: 50\" #> [1] \"Rips diagram: 51\" #> [1] \"Rips diagram: 52\" #> [1] \"Rips diagram: 53\" #> [1] \"Rips diagram: 54\" #> [1] \"Rips diagram: 55\" #> [1] \"Rips diagram: 56\" #> [1] \"Rips diagram: 57\" #> [1] \"Rips diagram: 58\" #> [1] \"Rips diagram: 59\" #> [1] \"Rips diagram: 60\" #> [1] \"Rips diagram: 61\" #> [1] \"Rips diagram: 62\" #> [1] \"Rips diagram: 63\" #> [1] \"Rips diagram: 64\" #> [1] \"Rips diagram: 65\" #> [1] \"Rips diagram: 66\" #> [1] \"Rips diagram: 67\" #> [1] \"Rips diagram: 68\" #> [1] \"Rips diagram: 69\" #> [1] \"Rips diagram: 70\" #> [1] \"Rips diagram: 71\" #> [1] \"Rips diagram: 72\" #> [1] \"Rips diagram: 73\" #> [1] \"Rips diagram: 74\" #> [1] \"Rips diagram: 75\" #> [1] \"Rips diagram: 76\" #> [1] \"Rips diagram: 77\" #> [1] \"Rips diagram: 78\" #> [1] \"Rips diagram: 79\" #> [1] \"Rips diagram: 80\" #> [1] \"Rips diagram: 81\" #> [1] \"Rips diagram: 82\" #> [1] \"Rips diagram: 83\" #> [1] \"Rips diagram: 84\" #> [1] \"Rips diagram: 85\" #> [1] \"Rips diagram: 86\" #> [1] \"Rips diagram: 87\" #> [1] \"Rips diagram: 88\" #> [1] \"Rips diagram: 89\" #> [1] \"Rips diagram: 90\" #> [1] \"Rips diagram: 91\" #> [1] \"Rips diagram: 92\" #> [1] \"Rips diagram: 93\" #> [1] \"Rips diagram: 94\" #> [1] \"Rips diagram: 95\" #> [1] \"Rips diagram: 96\" #> [1] \"Rips diagram: 97\" #> [1] \"Rips diagram: 98\" #> [1] \"Rips diagram: 99\" #> [1] \"Rips diagram: 100\"  # Then, run TopKAT res <- TopKAT(y = y,               cens = cens,               K.list = simmat$K.list,               omega.list = c(0, 0.5, 1),               outcome.type = \"survival\")  # Check result res$overall.pval #> [1] 3.443675e-05"},{"path":"https://sarahsamorodnitsky.github.io/TopKAT/reference/cens.html","id":null,"dir":"Reference","previous_headings":"","what":"Event indicator vector cens — cens","title":"Event indicator vector cens — cens","text":"vector contains binary indicators reflecting whether sample event. vector equals 1, indicates corresponding patient event 0 otherwise.","code":""},{"path":"https://sarahsamorodnitsky.github.io/TopKAT/reference/cens.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Event indicator vector cens — cens","text":"","code":"cens"},{"path":[]},{"path":"https://sarahsamorodnitsky.github.io/TopKAT/reference/cens.html","id":"cens","dir":"Reference","previous_headings":"","what":"cens","title":"Event indicator vector cens — cens","text":"vector length 100 event indicators.","code":""},{"path":"https://sarahsamorodnitsky.github.io/TopKAT/reference/data1.df.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulated data 1 — data1.df","title":"Simulated data 1 — data1.df","text":"dataset contains simulated data. images split two groups. first group simulated large squares. second group simulated loops. dataset contains 100 samples.","code":""},{"path":"https://sarahsamorodnitsky.github.io/TopKAT/reference/data1.df.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulated data 1 — data1.df","text":"","code":"data1.df"},{"path":[]},{"path":"https://sarahsamorodnitsky.github.io/TopKAT/reference/data1.df.html","id":"data-df","dir":"Reference","previous_headings":"","what":"data1.df","title":"Simulated data 1 — data1.df","text":"data frame 29951 rows 4 columns: PID Patient ID id Image ID (matches Patient ID) x x-coordinate cell y y-coordinate cell","code":""},{"path":"https://sarahsamorodnitsky.github.io/TopKAT/reference/data2.df.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulated data 2 — data2.df","title":"Simulated data 2 — data2.df","text":"dataset contains simulated data. images simulated using scSpatialSIM package represent different tissue structures. Specifically, used scSpatialSIM simulate two different tissues separated different images. dataset contains 100 samples.","code":""},{"path":"https://sarahsamorodnitsky.github.io/TopKAT/reference/data2.df.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulated data 2 — data2.df","text":"","code":"data2.df"},{"path":[]},{"path":"https://sarahsamorodnitsky.github.io/TopKAT/reference/data2.df.html","id":"data-df","dir":"Reference","previous_headings":"","what":"data2.df","title":"Simulated data 2 — data2.df","text":"data frame 100481 rows 4 columns: PID Patient ID id Image ID (matches Patient ID) x x-coordinate cell y y-coordinate cell","code":""},{"path":"https://sarahsamorodnitsky.github.io/TopKAT/reference/generate_connectivity.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate connectivity matrix — generate_connectivity","title":"Generate connectivity matrix — generate_connectivity","text":"Based radius lowest TopKAT p-value, compute connections matrix shows many edges cells type simplicial complex constructed based radius.","code":""},{"path":"https://sarahsamorodnitsky.github.io/TopKAT/reference/generate_connectivity.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate connectivity matrix — generate_connectivity","text":"","code":"generate_connectivity(images.df, threshold, type.column, unique.types)"},{"path":"https://sarahsamorodnitsky.github.io/TopKAT/reference/generate_connectivity.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate connectivity matrix — generate_connectivity","text":"images.df data.frame containing image information. See details. threshold Radius generate connectivity type.column name column images.df contains cell types unique.types Vector unique cell types type.column","code":""},{"path":"https://sarahsamorodnitsky.github.io/TopKAT/reference/generate_connectivity.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate connectivity matrix — generate_connectivity","text":"Returns connectivity matrix dimension \\(n\\times n\\) \\(n\\) number cell types, .e. length unique.types","code":""},{"path":"https://sarahsamorodnitsky.github.io/TopKAT/reference/generate_connectivity.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generate connectivity matrix — generate_connectivity","text":"images.df contain PID column indicating sample image corresponds . also contain columns x y indicating location cell. row images.df corresponds cell within image. See package vignettes example structure. function may take several minutes run require substantial amount memory. memory limit reached, consider running mem.maxVSize(vsize = x) specify x large value.","code":""},{"path":"https://sarahsamorodnitsky.github.io/TopKAT/reference/generate_connectivity.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate connectivity matrix — generate_connectivity","text":"","code":"require(magrittr) #> Loading required package: magrittr conmat <- generate_connectivity(data1.df %>% dplyr::filter(PID == 1), threshold = 10,                                 type.column = \"type\", unique.types = unique(data1.df$type))"},{"path":"https://sarahsamorodnitsky.github.io/TopKAT/reference/generate_rips.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate a list of persistence diagrams — generate_rips","title":"Generate a list of persistence diagrams — generate_rips","text":"Construct Rips filtration image return list persistence diagrams. helper function scale_importance.","code":""},{"path":"https://sarahsamorodnitsky.github.io/TopKAT/reference/generate_rips.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate a list of persistence diagrams — generate_rips","text":"","code":"generate_rips(images.df, max.threshold, print.progress = TRUE)"},{"path":"https://sarahsamorodnitsky.github.io/TopKAT/reference/generate_rips.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate a list of persistence diagrams — generate_rips","text":"images.df data.frame containing image information. See details. max.threshold maximum radius circles Rips filtration print.progress Boolean indicating whether progress constructing Rips filtrations across images printed.","code":""},{"path":"https://sarahsamorodnitsky.github.io/TopKAT/reference/generate_rips.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate a list of persistence diagrams — generate_rips","text":"Returns list persistence diagrams image.","code":""},{"path":"https://sarahsamorodnitsky.github.io/TopKAT/reference/generate_rips.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate a list of persistence diagrams — generate_rips","text":"","code":"# Generate a persistence diagram based on a Rips filtration for each image pd.list <- generate_rips(data1.df, 100) #> [1] \"Rips diagram: 1\" #> [1] \"Rips diagram: 2\" #> [1] \"Rips diagram: 3\" #> [1] \"Rips diagram: 4\" #> [1] \"Rips diagram: 5\" #> [1] \"Rips diagram: 6\" #> [1] \"Rips diagram: 7\" #> [1] \"Rips diagram: 8\" #> [1] \"Rips diagram: 9\" #> [1] \"Rips diagram: 10\" #> [1] \"Rips diagram: 11\" #> [1] \"Rips diagram: 12\" #> [1] \"Rips diagram: 13\" #> [1] \"Rips diagram: 14\" #> [1] \"Rips diagram: 15\" #> [1] \"Rips diagram: 16\" #> [1] \"Rips diagram: 17\" #> [1] \"Rips diagram: 18\" #> [1] \"Rips diagram: 19\" #> [1] \"Rips diagram: 20\" #> [1] \"Rips diagram: 21\" #> [1] \"Rips diagram: 22\" #> [1] \"Rips diagram: 23\" #> [1] \"Rips diagram: 24\" #> [1] \"Rips diagram: 25\" #> [1] \"Rips diagram: 26\" #> [1] \"Rips diagram: 27\" #> [1] \"Rips diagram: 28\" #> [1] \"Rips diagram: 29\" #> [1] \"Rips diagram: 30\" #> [1] \"Rips diagram: 31\" #> [1] \"Rips diagram: 32\" #> [1] \"Rips diagram: 33\" #> [1] \"Rips diagram: 34\" #> [1] \"Rips diagram: 35\" #> [1] \"Rips diagram: 36\" #> [1] \"Rips diagram: 37\" #> [1] \"Rips diagram: 38\" #> [1] \"Rips diagram: 39\" #> [1] \"Rips diagram: 40\" #> [1] \"Rips diagram: 41\" #> [1] \"Rips diagram: 42\" #> [1] \"Rips diagram: 43\" #> [1] \"Rips diagram: 44\" #> [1] \"Rips diagram: 45\" #> [1] \"Rips diagram: 46\" #> [1] \"Rips diagram: 47\" #> [1] \"Rips diagram: 48\" #> [1] \"Rips diagram: 49\" #> [1] \"Rips diagram: 50\" #> [1] \"Rips diagram: 51\" #> [1] \"Rips diagram: 52\" #> [1] \"Rips diagram: 53\" #> [1] \"Rips diagram: 54\" #> [1] \"Rips diagram: 55\" #> [1] \"Rips diagram: 56\" #> [1] \"Rips diagram: 57\" #> [1] \"Rips diagram: 58\" #> [1] \"Rips diagram: 59\" #> [1] \"Rips diagram: 60\" #> [1] \"Rips diagram: 61\" #> [1] \"Rips diagram: 62\" #> [1] \"Rips diagram: 63\" #> [1] \"Rips diagram: 64\" #> [1] \"Rips diagram: 65\" #> [1] \"Rips diagram: 66\" #> [1] \"Rips diagram: 67\" #> [1] \"Rips diagram: 68\" #> [1] \"Rips diagram: 69\" #> [1] \"Rips diagram: 70\" #> [1] \"Rips diagram: 71\" #> [1] \"Rips diagram: 72\" #> [1] \"Rips diagram: 73\" #> [1] \"Rips diagram: 74\" #> [1] \"Rips diagram: 75\" #> [1] \"Rips diagram: 76\" #> [1] \"Rips diagram: 77\" #> [1] \"Rips diagram: 78\" #> [1] \"Rips diagram: 79\" #> [1] \"Rips diagram: 80\" #> [1] \"Rips diagram: 81\" #> [1] \"Rips diagram: 82\" #> [1] \"Rips diagram: 83\" #> [1] \"Rips diagram: 84\" #> [1] \"Rips diagram: 85\" #> [1] \"Rips diagram: 86\" #> [1] \"Rips diagram: 87\" #> [1] \"Rips diagram: 88\" #> [1] \"Rips diagram: 89\" #> [1] \"Rips diagram: 90\" #> [1] \"Rips diagram: 91\" #> [1] \"Rips diagram: 92\" #> [1] \"Rips diagram: 93\" #> [1] \"Rips diagram: 94\" #> [1] \"Rips diagram: 95\" #> [1] \"Rips diagram: 96\" #> [1] \"Rips diagram: 97\" #> [1] \"Rips diagram: 98\" #> [1] \"Rips diagram: 99\" #> [1] \"Rips diagram: 100\""},{"path":"https://sarahsamorodnitsky.github.io/TopKAT/reference/plot_cell_connections.html","id":null,"dir":"Reference","previous_headings":"","what":"Heatmap of cell-cell connections — plot_cell_connections","title":"Heatmap of cell-cell connections — plot_cell_connections","text":"Visualize connectivity matrix produced generate_connectivity","code":""},{"path":"https://sarahsamorodnitsky.github.io/TopKAT/reference/plot_cell_connections.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Heatmap of cell-cell connections — plot_cell_connections","text":"","code":"plot_cell_connections(image, threshold, title, type.column, unique.types)"},{"path":"https://sarahsamorodnitsky.github.io/TopKAT/reference/plot_cell_connections.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Heatmap of cell-cell connections — plot_cell_connections","text":"image data.frame containing image information. threshold Radius plot, usually threshold generated scale_importance title Plot title type.column name column images.df contains cell types unique.types Vector unique cell types type.column","code":""},{"path":"https://sarahsamorodnitsky.github.io/TopKAT/reference/plot_cell_connections.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Heatmap of cell-cell connections — plot_cell_connections","text":"Returns ggplot heatmap cell-cell connections.","code":""},{"path":"https://sarahsamorodnitsky.github.io/TopKAT/reference/plot_cell_connections.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Heatmap of cell-cell connections — plot_cell_connections","text":"","code":"require(magrittr) plot_cell_connections(    image = data1.df %>% dplyr::filter(PID == 1),    threshold = 10,    title = \"\",    type.column = \"type\",    unique.types = unique(data1.df$type) )"},{"path":"https://sarahsamorodnitsky.github.io/TopKAT/reference/plot_cells_with_scale.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot cells with radius value — plot_cells_with_scale","title":"Plot cells with radius value — plot_cells_with_scale","text":"function plots simplicial complex cells points given radius value connecting .","code":""},{"path":"https://sarahsamorodnitsky.github.io/TopKAT/reference/plot_cells_with_scale.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot cells with radius value — plot_cells_with_scale","text":"","code":"plot_cells_with_scale(image, threshold, title)"},{"path":"https://sarahsamorodnitsky.github.io/TopKAT/reference/plot_cells_with_scale.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot cells with radius value — plot_cells_with_scale","text":"image data.frame containing cell information single image. threshold Radius plot title Title plot","code":""},{"path":"https://sarahsamorodnitsky.github.io/TopKAT/reference/plot_cells_with_scale.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot cells with radius value — plot_cells_with_scale","text":"Returns ggplot scatterplot data edges length threshold connecting cells.","code":""},{"path":"https://sarahsamorodnitsky.github.io/TopKAT/reference/plot_cells_with_scale.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot cells with radius value — plot_cells_with_scale","text":"","code":"require(magrittr) plot_cells_with_scale(   image = data1.df %>% dplyr::filter(PID == 51),   threshold = 10,   title = \"Example Plot of Cells\" )"},{"path":"https://sarahsamorodnitsky.github.io/TopKAT/reference/plot_persistence.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot persistence diagrams — plot_persistence","title":"Plot persistence diagrams — plot_persistence","text":"Plot persistence diagrams","code":""},{"path":"https://sarahsamorodnitsky.github.io/TopKAT/reference/plot_persistence.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot persistence diagrams — plot_persistence","text":"","code":"plot_persistence(PD, title, dims = c(100, 100))"},{"path":"https://sarahsamorodnitsky.github.io/TopKAT/reference/plot_persistence.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot persistence diagrams — plot_persistence","text":"PD Persistence diagram given image title Title output figure dims Dimensions output figure","code":""},{"path":"https://sarahsamorodnitsky.github.io/TopKAT/reference/plot_persistence.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot persistence diagrams — plot_persistence","text":"Plot illustrating birth death scales homology","code":""},{"path":"https://sarahsamorodnitsky.github.io/TopKAT/reference/plot_persistence.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot persistence diagrams — plot_persistence","text":"","code":"require(magrittr) PD <- TDAstats::calculate_homology(        data2.df %>% dplyr::filter(PID == 1) %>% dplyr::select(x,y),        dim = 1,        threshold = 10) plot_persistence(PD = PD, title = \"Example Persistence Diagram\", dims = c(10, 10))"},{"path":"https://sarahsamorodnitsky.github.io/TopKAT/reference/rips_similarity_matrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate a similarity matrix based on the Rips filtration — rips_similarity_matrix","title":"Calculate a similarity matrix based on the Rips filtration — rips_similarity_matrix","text":"Given input data, computes Rips filtration persistence diagram image. constructs pairwise similarity matrix homology group (connected components loops) based resulting persistence diagrams.","code":""},{"path":"https://sarahsamorodnitsky.github.io/TopKAT/reference/rips_similarity_matrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate a similarity matrix based on the Rips filtration — rips_similarity_matrix","text":"","code":"rips_similarity_matrix(images.df, max.threshold, print.progress = TRUE)"},{"path":"https://sarahsamorodnitsky.github.io/TopKAT/reference/rips_similarity_matrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate a similarity matrix based on the Rips filtration — rips_similarity_matrix","text":"images.df data.frame containing image information. See details. max.threshold maximum radius circles Rips filtration print.progress Boolean indicating whether progress constructing Rips filtrations across images printed.","code":""},{"path":"https://sarahsamorodnitsky.github.io/TopKAT/reference/rips_similarity_matrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate a similarity matrix based on the Rips filtration — rips_similarity_matrix","text":"Returns list similarity (kernel) matrices list resulting persistence diagrams image.","code":""},{"path":"https://sarahsamorodnitsky.github.io/TopKAT/reference/rips_similarity_matrix.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate a similarity matrix based on the Rips filtration — rips_similarity_matrix","text":"images.df contain PID column indicating sample image corresponds . also contain columns x y indicating location cell. row images.df corresponds cell within image. See package vignettes example structure. choose max.threshold, reasonable first choice select maximum possible radius cover cells image. maximum width largest image, example. function run first step TopKAT analysis. , resulting kernel matrices may fed TopKAT function.","code":""},{"path":"https://sarahsamorodnitsky.github.io/TopKAT/reference/rips_similarity_matrix.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate a similarity matrix based on the Rips filtration — rips_similarity_matrix","text":"","code":"# Construct a Rips filtration for each simulated image simmat <- rips_similarity_matrix(data1.df, max.threshold = 100, print.progress = TRUE) #> [1] \"Rips diagram: 1\" #> [1] \"Rips diagram: 2\" #> [1] \"Rips diagram: 3\" #> [1] \"Rips diagram: 4\" #> [1] \"Rips diagram: 5\" #> [1] \"Rips diagram: 6\" #> [1] \"Rips diagram: 7\" #> [1] \"Rips diagram: 8\" #> [1] \"Rips diagram: 9\" #> [1] \"Rips diagram: 10\" #> [1] \"Rips diagram: 11\" #> [1] \"Rips diagram: 12\" #> [1] \"Rips diagram: 13\" #> [1] \"Rips diagram: 14\" #> [1] \"Rips diagram: 15\" #> [1] \"Rips diagram: 16\" #> [1] \"Rips diagram: 17\" #> [1] \"Rips diagram: 18\" #> [1] \"Rips diagram: 19\" #> [1] \"Rips diagram: 20\" #> [1] \"Rips diagram: 21\" #> [1] \"Rips diagram: 22\" #> [1] \"Rips diagram: 23\" #> [1] \"Rips diagram: 24\" #> [1] \"Rips diagram: 25\" #> [1] \"Rips diagram: 26\" #> [1] \"Rips diagram: 27\" #> [1] \"Rips diagram: 28\" #> [1] \"Rips diagram: 29\" #> [1] \"Rips diagram: 30\" #> [1] \"Rips diagram: 31\" #> [1] \"Rips diagram: 32\" #> [1] \"Rips diagram: 33\" #> [1] \"Rips diagram: 34\" #> [1] \"Rips diagram: 35\" #> [1] \"Rips diagram: 36\" #> [1] \"Rips diagram: 37\" #> [1] \"Rips diagram: 38\" #> [1] \"Rips diagram: 39\" #> [1] \"Rips diagram: 40\" #> [1] \"Rips diagram: 41\" #> [1] \"Rips diagram: 42\" #> [1] \"Rips diagram: 43\" #> [1] \"Rips diagram: 44\" #> [1] \"Rips diagram: 45\" #> [1] \"Rips diagram: 46\" #> [1] \"Rips diagram: 47\" #> [1] \"Rips diagram: 48\" #> [1] \"Rips diagram: 49\" #> [1] \"Rips diagram: 50\" #> [1] \"Rips diagram: 51\" #> [1] \"Rips diagram: 52\" #> [1] \"Rips diagram: 53\" #> [1] \"Rips diagram: 54\" #> [1] \"Rips diagram: 55\" #> [1] \"Rips diagram: 56\" #> [1] \"Rips diagram: 57\" #> [1] \"Rips diagram: 58\" #> [1] \"Rips diagram: 59\" #> [1] \"Rips diagram: 60\" #> [1] \"Rips diagram: 61\" #> [1] \"Rips diagram: 62\" #> [1] \"Rips diagram: 63\" #> [1] \"Rips diagram: 64\" #> [1] \"Rips diagram: 65\" #> [1] \"Rips diagram: 66\" #> [1] \"Rips diagram: 67\" #> [1] \"Rips diagram: 68\" #> [1] \"Rips diagram: 69\" #> [1] \"Rips diagram: 70\" #> [1] \"Rips diagram: 71\" #> [1] \"Rips diagram: 72\" #> [1] \"Rips diagram: 73\" #> [1] \"Rips diagram: 74\" #> [1] \"Rips diagram: 75\" #> [1] \"Rips diagram: 76\" #> [1] \"Rips diagram: 77\" #> [1] \"Rips diagram: 78\" #> [1] \"Rips diagram: 79\" #> [1] \"Rips diagram: 80\" #> [1] \"Rips diagram: 81\" #> [1] \"Rips diagram: 82\" #> [1] \"Rips diagram: 83\" #> [1] \"Rips diagram: 84\" #> [1] \"Rips diagram: 85\" #> [1] \"Rips diagram: 86\" #> [1] \"Rips diagram: 87\" #> [1] \"Rips diagram: 88\" #> [1] \"Rips diagram: 89\" #> [1] \"Rips diagram: 90\" #> [1] \"Rips diagram: 91\" #> [1] \"Rips diagram: 92\" #> [1] \"Rips diagram: 93\" #> [1] \"Rips diagram: 94\" #> [1] \"Rips diagram: 95\" #> [1] \"Rips diagram: 96\" #> [1] \"Rips diagram: 97\" #> [1] \"Rips diagram: 98\" #> [1] \"Rips diagram: 99\" #> [1] \"Rips diagram: 100\""},{"path":"https://sarahsamorodnitsky.github.io/TopKAT/reference/scale_importance.html","id":null,"dir":"Reference","previous_headings":"","what":"Quantifying the importance of scale — scale_importance","title":"Quantifying the importance of scale — scale_importance","text":"Identify distance important characterizing association topological structure image outcomes.","code":""},{"path":"https://sarahsamorodnitsky.github.io/TopKAT/reference/scale_importance.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Quantifying the importance of scale — scale_importance","text":"","code":"scale_importance(   pd.list,   y,   X = NULL,   cens = NULL,   omega.list,   threshold,   PIDs,   outcome.type = \"continuous\",   n.thresh = 50,   print.progress = FALSE )"},{"path":"https://sarahsamorodnitsky.github.io/TopKAT/reference/scale_importance.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Quantifying the importance of scale — scale_importance","text":"pd.list List persistence diagrams y Outcome vector X Covariates adjust , desired. May left NULL. cens Censoring vector survival outcomes. May left NULL. omega.list Vector weights combine kernel matrices threshold Maximum radius Rips filtration PIDs Vector patient IDs outcome.type Outcome type, options include \"continuous\", \"binary\", \"survival\" n.thresh Number distances cells evaluate. Default 50 print.progress Boolean, progress printed throughout analysis?","code":""},{"path":"https://sarahsamorodnitsky.github.io/TopKAT/reference/scale_importance.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Quantifying the importance of scale — scale_importance","text":"Returns list following elements: min.thresh distance value lowest TopKAT p-value obtained pvals vector TopKAT p-values radius value threshold.seq vector distances considered","code":""},{"path":"https://sarahsamorodnitsky.github.io/TopKAT/reference/scale_importance.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Quantifying the importance of scale — scale_importance","text":"function identifies distance features born died process filtration associated outcome.","code":""},{"path":"https://sarahsamorodnitsky.github.io/TopKAT/reference/scale_importance.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Quantifying the importance of scale — scale_importance","text":"","code":"# Generate a persistence diagram based on a Rips filtration for each image pd.list <- generate_rips(data1.df, 100) #> [1] \"Rips diagram: 1\" #> [1] \"Rips diagram: 2\" #> [1] \"Rips diagram: 3\" #> [1] \"Rips diagram: 4\" #> [1] \"Rips diagram: 5\" #> [1] \"Rips diagram: 6\" #> [1] \"Rips diagram: 7\" #> [1] \"Rips diagram: 8\" #> [1] \"Rips diagram: 9\" #> [1] \"Rips diagram: 10\" #> [1] \"Rips diagram: 11\" #> [1] \"Rips diagram: 12\" #> [1] \"Rips diagram: 13\" #> [1] \"Rips diagram: 14\" #> [1] \"Rips diagram: 15\" #> [1] \"Rips diagram: 16\" #> [1] \"Rips diagram: 17\" #> [1] \"Rips diagram: 18\" #> [1] \"Rips diagram: 19\" #> [1] \"Rips diagram: 20\" #> [1] \"Rips diagram: 21\" #> [1] \"Rips diagram: 22\" #> [1] \"Rips diagram: 23\" #> [1] \"Rips diagram: 24\" #> [1] \"Rips diagram: 25\" #> [1] \"Rips diagram: 26\" #> [1] \"Rips diagram: 27\" #> [1] \"Rips diagram: 28\" #> [1] \"Rips diagram: 29\" #> [1] \"Rips diagram: 30\" #> [1] \"Rips diagram: 31\" #> [1] \"Rips diagram: 32\" #> [1] \"Rips diagram: 33\" #> [1] \"Rips diagram: 34\" #> [1] \"Rips diagram: 35\" #> [1] \"Rips diagram: 36\" #> [1] \"Rips diagram: 37\" #> [1] \"Rips diagram: 38\" #> [1] \"Rips diagram: 39\" #> [1] \"Rips diagram: 40\" #> [1] \"Rips diagram: 41\" #> [1] \"Rips diagram: 42\" #> [1] \"Rips diagram: 43\" #> [1] \"Rips diagram: 44\" #> [1] \"Rips diagram: 45\" #> [1] \"Rips diagram: 46\" #> [1] \"Rips diagram: 47\" #> [1] \"Rips diagram: 48\" #> [1] \"Rips diagram: 49\" #> [1] \"Rips diagram: 50\" #> [1] \"Rips diagram: 51\" #> [1] \"Rips diagram: 52\" #> [1] \"Rips diagram: 53\" #> [1] \"Rips diagram: 54\" #> [1] \"Rips diagram: 55\" #> [1] \"Rips diagram: 56\" #> [1] \"Rips diagram: 57\" #> [1] \"Rips diagram: 58\" #> [1] \"Rips diagram: 59\" #> [1] \"Rips diagram: 60\" #> [1] \"Rips diagram: 61\" #> [1] \"Rips diagram: 62\" #> [1] \"Rips diagram: 63\" #> [1] \"Rips diagram: 64\" #> [1] \"Rips diagram: 65\" #> [1] \"Rips diagram: 66\" #> [1] \"Rips diagram: 67\" #> [1] \"Rips diagram: 68\" #> [1] \"Rips diagram: 69\" #> [1] \"Rips diagram: 70\" #> [1] \"Rips diagram: 71\" #> [1] \"Rips diagram: 72\" #> [1] \"Rips diagram: 73\" #> [1] \"Rips diagram: 74\" #> [1] \"Rips diagram: 75\" #> [1] \"Rips diagram: 76\" #> [1] \"Rips diagram: 77\" #> [1] \"Rips diagram: 78\" #> [1] \"Rips diagram: 79\" #> [1] \"Rips diagram: 80\" #> [1] \"Rips diagram: 81\" #> [1] \"Rips diagram: 82\" #> [1] \"Rips diagram: 83\" #> [1] \"Rips diagram: 84\" #> [1] \"Rips diagram: 85\" #> [1] \"Rips diagram: 86\" #> [1] \"Rips diagram: 87\" #> [1] \"Rips diagram: 88\" #> [1] \"Rips diagram: 89\" #> [1] \"Rips diagram: 90\" #> [1] \"Rips diagram: 91\" #> [1] \"Rips diagram: 92\" #> [1] \"Rips diagram: 93\" #> [1] \"Rips diagram: 94\" #> [1] \"Rips diagram: 95\" #> [1] \"Rips diagram: 96\" #> [1] \"Rips diagram: 97\" #> [1] \"Rips diagram: 98\" #> [1] \"Rips diagram: 99\" #> [1] \"Rips diagram: 100\" # Run the scale importance analysis data1.scale <- scale_importance(pd.list = pd.list,   y = y,   cens = cens,   omega.list = c(0, 0.5, 1),   threshold = 100,   PIDs = 1:100,   outcome.type = \"survival\")  # Plot the results plot(data1.scale$threshold.seq, data1.scale$pvals); abline(v = data1.scale$min.thresh)"},{"path":"https://sarahsamorodnitsky.github.io/TopKAT/reference/similarity_matrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Construct a pairwise similarity matrix — similarity_matrix","title":"Construct a pairwise similarity matrix — similarity_matrix","text":"similarity_matrix helper function used within rips_similarity_matrix construct pairwise similarity matrix comparing pairs persistence diagrams.","code":""},{"path":"https://sarahsamorodnitsky.github.io/TopKAT/reference/similarity_matrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Construct a pairwise similarity matrix — similarity_matrix","text":"","code":"similarity_matrix(rips.list, n.sample, PIDs, print.progress = FALSE)"},{"path":"https://sarahsamorodnitsky.github.io/TopKAT/reference/similarity_matrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Construct a pairwise similarity matrix — similarity_matrix","text":"rips.list list persistence diagrams sample n.sample number samples dataset (length rips.list) PIDs Unique identifiers sample. used name resulting similarity matrix. print.progress progress bar printed?","code":""},{"path":"https://sarahsamorodnitsky.github.io/TopKAT/reference/similarity_matrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Construct a pairwise similarity matrix — similarity_matrix","text":"Returns list kernel (similarity matrices) homology group.","code":""},{"path":"https://sarahsamorodnitsky.github.io/TopKAT/reference/similarity_matrix.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Construct a pairwise similarity matrix — similarity_matrix","text":"","code":"require(magrittr) require(TDAstats) #> Loading required package: TDAstats  # Save the PIDs PIDs <- unique(data1.df$PID)  # Save the number of samples n.sample <- length(PIDs)  # Initialize a list to store the Rips filtrations rips.list <- lapply(1:n.sample, function(i) list()); names(rips.list) <- PIDs  # Iterate through the samples to construct Rips filtration for (i in PIDs) {    # Subset the data to just this PID  data.i <- data1.df %>%    dplyr::filter(PID == i) %>%    dplyr::select(x,y)   # Construct a Rips filtration using TDAstats  rips.i <- TDAstats::calculate_homology(data.i, dim = 1, threshold = 10)   # Save  rips.list[[i]] <- rips.i }  K.list <- similarity_matrix(rips.list, n.sample, PIDs)"},{"path":"https://sarahsamorodnitsky.github.io/TopKAT/reference/tnbc.html","id":null,"dir":"Reference","previous_headings":"","what":"MIBI Data from study in Triple Negative Breast Csancer — tnbc","title":"MIBI Data from study in Triple Negative Breast Csancer — tnbc","text":"dataset contains simulated data. images split two groups. first group simulated large squares. second group simulated loops. dataset contains 100 samples.","code":""},{"path":"https://sarahsamorodnitsky.github.io/TopKAT/reference/tnbc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"MIBI Data from study in Triple Negative Breast Csancer — tnbc","text":"","code":"tnbc"},{"path":[]},{"path":"https://sarahsamorodnitsky.github.io/TopKAT/reference/tnbc.html","id":"tnbc","dir":"Reference","previous_headings":"","what":"tnbc","title":"MIBI Data from study in Triple Negative Breast Csancer — tnbc","text":"data frame 175497 rows 8 columns: SampleID Patient ID Group Indicates cell type. 2=immune cell, 6=keratin-positive tumor cell immuneGroup Indicates granular immune cell type defintion x x-coordinate cell y y-coordinate cell Survival_days_capped* Time--death days Censored Survival event indicator (1=event; 0=censored) Class Tumor microenvironment class. 0=mixed; 1=compartmentalized; 2=cold","code":""},{"path":"https://sarahsamorodnitsky.github.io/TopKAT/reference/tnbc.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"MIBI Data from study in Triple Negative Breast Csancer — tnbc","text":"Keren, L., Bosse, M., Marquez, D., Angoshtari, R., Jain, S., Varma, S., ... & Angelo, M. (2018). structured tumor-immune microenvironment triple negative breast cancer revealed multiplexed ion beam imaging. Cell, 174(6), 1373-1387.","code":""},{"path":"https://sarahsamorodnitsky.github.io/TopKAT/reference/y.html","id":null,"dir":"Reference","previous_headings":"","what":"Outcome vector y — y","title":"Outcome vector y — y","text":"vector contains outcomes simulated data. simulated survival outcomes exponential distribution. 100 samples, simulated event times two different exponential distributions.","code":""},{"path":"https://sarahsamorodnitsky.github.io/TopKAT/reference/y.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Outcome vector y — y","text":"","code":"y"},{"path":[]},{"path":"https://sarahsamorodnitsky.github.io/TopKAT/reference/y.html","id":"y","dir":"Reference","previous_headings":"","what":"y","title":"Outcome vector y — y","text":"vector length 100 event times.","code":""}]
