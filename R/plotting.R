#' Plot cells with radius value
#'
#' This function plots a simplicial complex with the cells as points and the
#' given radius value connecting them.
#'
#' @param image A data.frame containing the cell information for a single image.
#' @param threshold Radius to plot
#' @param title Title for the plot
#'
#' @return Returns a ggplot scatterplot of the data with edges of length
#' `threshold` connecting the cells.
#'
#' @import ggplot2
#' @importFrom magrittr %>%
#' @export
#'
#' @examples
#' require(magrittr)
#' plot_cells_with_scale(
#'   image = data1.df %>% dplyr::filter(PID == 51),
#'   threshold = 10,
#'   title = "Example Plot of Cells"
#' )
plot_cells_with_scale <- function(image, threshold, title) {

  # Construct distance matrix
  distances <- as.matrix(dist(image %>% dplyr::select(x,y)))

  # Create adjacency matrix based on threshold
  adj_matrix <- ifelse(distances <= threshold, 1, 0)

  # Obtain the edges
  edges <- which(adj_matrix == 1, arr.ind = TRUE)
  edges <- data.frame(
    from = image[edges[,1],],
    to = image[edges[,2],]
  )

  # Plot
  pp <- image %>%
    ggplot2::ggplot(aes(x = x, y = y)) +
    ggplot2::geom_point(alpha = 0.5, size = 0.5) +
    ggplot2::geom_segment(data = edges,
                          aes(x = from.x, y = from.y, xend = to.x, yend = to.y),
                          alpha = 0.05) +
    ggplot2::labs(x = "X", y = "Y") +
    ggplot2::theme_bw() +
    ggplot2::ggtitle(title) +
    ggplot2::theme(
      plot.title = element_text(size = 20),
      axis.title.x = element_text(size = 16),
      axis.title.y = element_text(size = 16),
      axis.text.x = element_text(size = 16),
      axis.text.y = element_text(size = 16)
    )

  # Return
  pp

}

#' Heatmap of cell-cell connections
#'
#' Visualize the connectivity matrix produced by `generate_connectivity`
#'
#' @param image A data.frame containing the image information.
#' @param threshold Radius to plot, usually `threshold` generated by `scale_importance`
#' @param title Plot title
#' @param type.column The name of the column in `images.df` that contains the cell types
#' @param unique.types Vector of unique cell types in the `type.column`
#'
#' @return Returns a ggplot of the heatmap of cell-cell connections.
#' @import ggplot2
#' @import viridis
#' @import reshape2
#' @export
#'
#' @examples
#' require(magrittr)
#' plot_cell_connections(
#'    image = data1.df %>% dplyr::filter(PID == 1),
#'    threshold = 10,
#'    title = "",
#'    type.column = "type",
#'    unique.types = unique(data1.df$type)
#' )
plot_cell_connections <- function(image, threshold, title, type.column, unique.types) {

  # Generate connectivity
  connectivity_matrix <- generate_connectivity(image, threshold, type.column, unique.types)

  # Convert NAs to 0s
  connectivity_matrix[is.na(connectivity_matrix)] <- 0

  # Plot the heatmap using ggplot2
  pp <- ggplot2::ggplot(reshape2::melt(connectivity_matrix), aes(Var1, Var2, fill = value)) +
    ggplot2::geom_tile(colour = "white") +
    viridis::scale_fill_viridis(option = "turbo") +
    ggplot2::labs(x = "Cell Type 1", y = "Cell Type 2", fill = "Number of Connections") +
    ggplot2::theme_minimal() +
    ggplot2::theme(axis.text.x = element_text(size = 12, angle = 45, hjust = 1),
          axis.text.y = element_text(size = 12),
          axis.title = element_text(size = 13),
          panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),
          legend.position = "bottom",
          legend.title = element_text(size = 12),
          legend.text = element_text(size = 11, angle = 45, hjust = 0.75),
          plot.title = element_text(size = 14)) +
    ggplot2::ggtitle(title)

  # Return plot
  pp

}

#' Generate connectivity matrix
#'
#' Based on the radius with the lowest TopKAT p-value, compute a connections
#' matrix that shows how many edges are between cells of each type at the
#' simplicial complex constructed based on this radius.
#'
#' @param images.df A data.frame containing the image information. See details.
#' @param threshold Radius to generate connectivity for
#' @param type.column The name of the column in `images.df` that contains the cell types
#' @param unique.types Vector of unique cell types in the `type.column`
#'
#' @details `images.df` should contain a `PID` column indicating which sample
#' each image corresponds to. It should also contain columns `x` and `y` indicating
#' the location of each cell. Each row in `images.df` corresponds to a cell within
#' each image. See the package vignettes for an example of the structure.
#'
#' This function may take several minutes to run and does require
#' a substantial amount of memory. If the memory limit is reached, consider
#' running `mem.maxVSize(vsize = x)` and specify `x` to a large value.
#'
#' @return Returns a connectivity matrix of dimension \eqn{n\times n} where \eqn{n}
#' is the number of cell types, i.e. the length of `unique.types`
#' @import dplyr
#' @import tidyr
#' @importFrom igraph graph_from_adjacency_matrix vertex_attr as_edgelist
#' @importFrom stats dist
#' @importFrom magrittr %>%
#' @export
#'
#' @examples
#' require(magrittr)
#' conmat <- generate_connectivity(data1.df %>% dplyr::filter(PID == 1), threshold = 10,
#'                                 type.column = "type", unique.types = unique(data1.df$type))
generate_connectivity <- function(images.df, threshold, type.column, unique.types) {

  # Check if unique.types is character()
  if (!is.character(unique.types)) unique.types <- sort(as.character(unique.types))

  # Construct the adjacency matrix
  distances <- as.matrix(stats::dist(images.df %>% select(x,y)))

  # Create adjacency matrix based on threshold
  adj_matrix <- ifelse(distances <= threshold, 1, 0)

  # Create network
  net <- igraph::graph_from_adjacency_matrix(adj_matrix, mode = "undirected", diag = FALSE)

  # Add the vertex attributes
  igraph::vertex_attr(net, "name") <- images.df[,type.column]

  # Check connectivity
  edges <- as.data.frame(igraph::as_edgelist(net))
  colnames(edges) <- c("from", "to")

  # Tabulate how many times each cell type connected with another cell type
  connectivity <- edges %>%
    dplyr::group_by(from, to) %>%
    dplyr::summarise(count = n()) %>%
    dplyr::ungroup()

  # Collapse the groups
  connectivity$group <- apply(connectivity[,1:2], 1, function(i) paste(sort(i), collapse = "-"))
  connectivity <- connectivity %>%
    dplyr::group_by(group) %>%
    dplyr::summarise(total.count = sum(count)) %>%
    dplyr::ungroup()

  # Add back in the group separations
  connectivity$from <- sapply(connectivity$group, function(i) strsplit(i, "-")[[1]][1])
  connectivity$to <- sapply(connectivity$group, function(i) strsplit(i, "-")[[1]][2])

  # Remove the group column
  connectivity <- connectivity[,-1]

  # Include all combinations of cell types
  connectivity.all <- expand.grid(unique.types, unique.types, stringsAsFactors = FALSE)
  colnames(connectivity.all) <- c("from", "to")

  # Merge with connectivity
  connectivity.all <- dplyr::left_join(connectivity.all, connectivity, by = c("from", "to"))

  # Convert NAs to 0s
  connectivity.all$total.count[is.na(connectivity.all$total.count)] <- 0

  # Pivot to a matrix
  connectivity_matrix <- connectivity.all %>%
    tidyr::pivot_wider(names_from = to, values_from = total.count)

  # Convert to matrix for the heatmap
  connectivity_matrix <- as.matrix(connectivity_matrix[,-1])
  rownames(connectivity_matrix) <- colnames(connectivity_matrix)

  # Make symmetric
  connectivity_matrix <- connectivity_matrix + t(connectivity_matrix) - diag(diag(connectivity_matrix))

  # Return
  connectivity_matrix

}

#' Plot persistence diagrams
#'
#' @param PD Persistence diagram for a given image
#' @param title Title for the output figure
#' @param dims Dimensions for the output figure
#'
#' @return Plot illustrating the birth and death scales for each homology
#' @import ggplot2
#' @import ggtda
#' @importFrom magrittr %>%
#' @export
#'
#' @examples
#' require(magrittr)
#' PD <- TDAstats::calculate_homology(
#'        data2.df %>% dplyr::filter(PID == 1) %>% dplyr::select(x,y),
#'        dim = 1,
#'        threshold = 10)
#' plot_persistence(PD = PD, title = "Example Persistence Diagram", dims = c(10, 10))
plot_persistence <- function(PD, title, dims = c(100, 100)) {

  PD <- as.data.frame(PD)
  PD$dimension <- factor(PD$dimension)
  levels(PD$dimension) <- c("Connected Component", "Loop")

  # Plot
  pp <- PD %>%
    ggplot2::ggplot() +
    coord_fixed() +
    ggtda::stat_persistence(aes(start = birth, end = death,
                                colour = dimension, shape = dimension), size = 2) +
    ggplot2::theme_bw() +
    ggplot2::geom_abline(slope = 1) +
    ggplot2::labs(x = "Birth", y = "Death", color = "Dimension", shape = "Dimension") +
    ggplot2::ggtitle(title) +
    ggplot2::xlim(0, dims[1]) + ylim(0, dims[2]) +
    ggplot2::theme(
      plot.title = element_text(size = 20),
      axis.title.x = element_text(size = 16),
      axis.title.y = element_text(size = 16),
      axis.text.x = element_text(size = 16),
      axis.text.y = element_text(size = 16),
      legend.text = element_text(size = 16),
      legend.title = element_text(size = 16),
      legend.position = "bottom"
    )

  # Return
  pp

}
